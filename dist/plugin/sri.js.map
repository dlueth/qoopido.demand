{"version":3,"sources":["plugin/sri.js"],"names":["SUPPORTED_ALGS","global","Int_64","msint_32","lsint_32","this","highOrder","lowOrder","packed2hex","packed","outputLength","bigEndianMod","formatOpts","i","srcByte","shiftModifier","hex_tab","str","length","charAt","outputUpper","toUpperCase","packed2b64","j","triplet","int1","int2","b64Pad","packed2bytes","String","fromCharCode","packed2arraybuffer","arrView","retVal","ArrayBuffer","Uint8Array","getOutputOpts","options","outputOptions","shakeLen","hasOwnProperty","Error","getStrConverter","format","utfType","existingBin","existingBinLen","existingPacked","existingPackedLen","num","intOffset","byteOffset","existingByteLen","parseInt","substr","isNaN","push","value","binLen","hex2packed","codePnt","codePntArr","transposeBytes","byteCnt","charCodeAt","str2packed","tmpInt","strPart","firstEqual","search","indexOf","replace","b642packed","bytes2packed","ignore","arr","byteLength","arraybuffer2packed","rotl_32","x","n","rotl_64","rotr_32","rotr_64","tmp","shr_32","shr_64","parity_32","y","z","ch_32","ch_64","maj_32","maj_64","sigma0_32","sigma0_64","rotr28","rotr34","rotr39","sigma1_32","sigma1_64","rotr14","rotr18","rotr41","gamma0_32","gamma0_64","rotr1","rotr8","shr7","gamma1_32","gamma1_64","rotr19","rotr61","shr6","safeAdd_32_2","a","b","lsw","safeAdd_32_4","c","d","safeAdd_32_5","e","safeAdd_64_2","msw","safeAdd_64_4","safeAdd_64_5","xor_64_2","getNewState","variant","H_trunc","H_full","lastIndexOf","roundSHA1","block","H","T","t","W","ch","parity","maj","rotl","safeAdd_2","safeAdd_5","finalizeSHA1","remainder","remainderBinLen","processedBinLen","outputLen","appendedMessageLength","offset","totalLen","TWO_PWR_32","slice","roundSHA2","f","g","h","T1","T2","numRounds","binaryStringMult","safeAdd_4","gamma0","gamma1","sigma0","sigma1","Int","K","K_sha512","Number","K_sha2","roundSHA3","state","round","B","C","D","r_sha3","rc_sha3","jsSHA","inputFormat","intermediateState","converterFunc","outputBinLen","variantBlockSize","roundFunc","finalizeFunc","stateCloneFunc","delimiter","processedLen","remainderLen","shaVariant","hmacKeySet","keyWithIPad","keyWithOPad","updatedCalled","isSHAKE","inputOptions","encoding","binaryStringInc","finalizeSHA2","clone","cloneSHA3State","blockSize","temp","state_offset","remainderIntLen","finalizeSHA3","setHMACKey","key","convertRet","keyBinLen","keyToUse","blockByteSize","lastArrayIndex","update","srcString","chunkBinLen","chunkIntLen","chunk","updateProcessedLen","variantBlockIntInc","getHash","formatFunc","finalizedState","binarray","getHMAC","firstHash","define","amd","exports","module","provide","path","Failure","iterate","isObject","settings","demand","on","dependency","sha","hash","match","type","source","dfd","reject","id","error"],"mappings":"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K,EAAA,GAAA,YAAA,IAAA1K,EAAA0K,EAAA,GAAA,YAAA,IAAA1K,EAAA0K,EAAA,GAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,WAAA,IAAA1K,EAAA0K,EAAA,IAAA,WAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,WAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,WAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,WAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,WAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,WAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,YAAA,IAAA1K,EAAA0K,EAAA,IAAA,WAAA,IAAA1K,EAAA0K,EAAA,IAAA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","file":"sri.js","sourcesContent":["/**! Qoopido.demand 5.0.1 | https://github.com/dlueth/qoopido.demand | (c) 2018 Dirk Lueth */\nvar SUPPORTED_ALGS = 15;\n(function (global) {\n\t\"use strict\";\n\n\tfunction Int_64(msint_32, lsint_32) {\n\t\tthis.highOrder = msint_32;\n\t\tthis.lowOrder = lsint_32\n\t}\n\n\tfunction str2packed(str, utfType, existingPacked, existingPackedLen, bigEndianMod) {\n\t\tvar packed, codePnt, codePntArr, i, j, existingByteLen, intOffset, byteOffset, shiftModifier, transposeBytes, byteCnt = 0;\n\t\tpacked = existingPacked || [0];\n\t\texistingByteLen = (existingPackedLen = existingPackedLen || 0) >>> 3;\n\t\tif (\"UTF8\" === utfType) {\n\t\t\tshiftModifier = -1 === bigEndianMod ? 3 : 0;\n\t\t\tfor (i = 0; i < str.length; i += 1) {\n\t\t\t\tcodePntArr = [];\n\t\t\t\tif (128 > (codePnt = str.charCodeAt(i))) codePntArr.push(codePnt);\n\t\t\t\telse if (2048 > codePnt) {\n\t\t\t\t\tcodePntArr.push(192 | codePnt >>> 6);\n\t\t\t\t\tcodePntArr.push(128 | 63 & codePnt)\n\t\t\t\t} else if (55296 > codePnt || 57344 <= codePnt) codePntArr.push(224 | codePnt >>> 12, 128 | codePnt >>> 6 & 63, 128 | 63 & codePnt);\n\t\t\t\telse {\n\t\t\t\t\ti += 1;\n\t\t\t\t\tcodePnt = 65536 + ((1023 & codePnt) << 10 | 1023 & str.charCodeAt(i));\n\t\t\t\t\tcodePntArr.push(240 | codePnt >>> 18, 128 | codePnt >>> 12 & 63, 128 | codePnt >>> 6 & 63, 128 | 63 & codePnt)\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < codePntArr.length; j += 1) {\n\t\t\t\t\tintOffset = (byteOffset = byteCnt + existingByteLen) >>> 2;\n\t\t\t\t\twhile (packed.length <= intOffset) packed.push(0);\n\t\t\t\t\tpacked[intOffset] |= codePntArr[j] << 8 * (shiftModifier + bigEndianMod * (byteOffset % 4));\n\t\t\t\t\tbyteCnt += 1\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (\"UTF16BE\" === utfType || \"UTF16LE\" === utfType) {\n\t\t\tshiftModifier = -1 === bigEndianMod ? 2 : 0;\n\t\t\ttransposeBytes = \"UTF16LE\" === utfType && 1 !== bigEndianMod || \"UTF16LE\" !== utfType && 1 === bigEndianMod;\n\t\t\tfor (i = 0; i < str.length; i += 1) {\n\t\t\t\tcodePnt = str.charCodeAt(i);\n\t\t\t\tif (true === transposeBytes) codePnt = (j = 255 & codePnt) << 8 | codePnt >>> 8;\n\t\t\t\tintOffset = (byteOffset = byteCnt + existingByteLen) >>> 2;\n\t\t\t\twhile (packed.length <= intOffset) packed.push(0);\n\t\t\t\tpacked[intOffset] |= codePnt << 8 * (shiftModifier + bigEndianMod * (byteOffset % 4));\n\t\t\t\tbyteCnt += 2\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tvalue: packed,\n\t\t\tbinLen: 8 * byteCnt + existingPackedLen\n\t\t}\n\t}\n\n\tfunction hex2packed(str, existingPacked, existingPackedLen, bigEndianMod) {\n\t\tvar packed, i, num, intOffset, byteOffset, existingByteLen, shiftModifier, length = str.length;\n\t\tif (0 !== length % 2) throw new Error(\"String of HEX type must be in byte increments\");\n\t\tpacked = existingPacked || [0];\n\t\texistingByteLen = (existingPackedLen = existingPackedLen || 0) >>> 3;\n\t\tshiftModifier = -1 === bigEndianMod ? 3 : 0;\n\t\tfor (i = 0; i < length; i += 2) {\n\t\t\tnum = parseInt(str.substr(i, 2), 16);\n\t\t\tif (!isNaN(num)) {\n\t\t\t\tintOffset = (byteOffset = (i >>> 1) + existingByteLen) >>> 2;\n\t\t\t\twhile (packed.length <= intOffset) packed.push(0);\n\t\t\t\tpacked[intOffset] |= num << 8 * (shiftModifier + bigEndianMod * (byteOffset % 4))\n\t\t\t} else throw new Error(\"String of HEX type contains invalid characters\")\n\t\t}\n\t\treturn {\n\t\t\tvalue: packed,\n\t\t\tbinLen: 4 * length + existingPackedLen\n\t\t}\n\t}\n\n\tfunction bytes2packed(str, existingPacked, existingPackedLen, bigEndianMod) {\n\t\tvar packed, codePnt, i, existingByteLen, intOffset, byteOffset, shiftModifier;\n\t\tpacked = existingPacked || [0];\n\t\texistingByteLen = (existingPackedLen = existingPackedLen || 0) >>> 3;\n\t\tshiftModifier = -1 === bigEndianMod ? 3 : 0;\n\t\tfor (i = 0; i < str.length; i += 1) {\n\t\t\tcodePnt = str.charCodeAt(i);\n\t\t\tintOffset = (byteOffset = i + existingByteLen) >>> 2;\n\t\t\tif (packed.length <= intOffset) packed.push(0);\n\t\t\tpacked[intOffset] |= codePnt << 8 * (shiftModifier + bigEndianMod * (byteOffset % 4))\n\t\t}\n\t\treturn {\n\t\t\tvalue: packed,\n\t\t\tbinLen: 8 * str.length + existingPackedLen\n\t\t}\n\t}\n\n\tfunction b642packed(str, existingPacked, existingPackedLen, bigEndianMod) {\n\t\tvar packed, i, j, tmpInt, strPart, firstEqual, existingByteLen, intOffset, byteOffset, shiftModifier, byteCnt = 0,\n\t\t\tb64Tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\t\tif (-1 === str.search(/^[a-zA-Z0-9=+\\/]+$/)) throw new Error(\"Invalid character in base-64 string\");\n\t\tfirstEqual = str.indexOf(\"=\");\n\t\tstr = str.replace(/\\=/g, \"\");\n\t\tif (-1 !== firstEqual && firstEqual < str.length) throw new Error(\"Invalid '=' found in base-64 string\");\n\t\tpacked = existingPacked || [0];\n\t\texistingByteLen = (existingPackedLen = existingPackedLen || 0) >>> 3;\n\t\tshiftModifier = -1 === bigEndianMod ? 3 : 0;\n\t\tfor (i = 0; i < str.length; i += 4) {\n\t\t\tstrPart = str.substr(i, 4);\n\t\t\ttmpInt = 0;\n\t\t\tfor (j = 0; j < strPart.length; j += 1) tmpInt |= b64Tab.indexOf(strPart[j]) << 18 - 6 * j;\n\t\t\tfor (j = 0; j < strPart.length - 1; j += 1) {\n\t\t\t\tintOffset = (byteOffset = byteCnt + existingByteLen) >>> 2;\n\t\t\t\twhile (packed.length <= intOffset) packed.push(0);\n\t\t\t\tpacked[intOffset] |= (tmpInt >>> 16 - 8 * j & 255) << 8 * (shiftModifier + bigEndianMod * (byteOffset % 4));\n\t\t\t\tbyteCnt += 1\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tvalue: packed,\n\t\t\tbinLen: 8 * byteCnt + existingPackedLen\n\t\t}\n\t}\n\n\tfunction arraybuffer2packed(arr, existingPacked, existingPackedLen, bigEndianMod) {\n\t\tvar packed, i, existingByteLen, intOffset, byteOffset, shiftModifier, arrView;\n\t\tpacked = existingPacked || [0];\n\t\texistingByteLen = (existingPackedLen = existingPackedLen || 0) >>> 3;\n\t\tshiftModifier = -1 === bigEndianMod ? 3 : 0;\n\t\tarrView = new Uint8Array(arr);\n\t\tfor (i = 0; i < arr.byteLength; i += 1) {\n\t\t\tintOffset = (byteOffset = i + existingByteLen) >>> 2;\n\t\t\tif (packed.length <= intOffset) packed.push(0);\n\t\t\tpacked[intOffset] |= arrView[i] << 8 * (shiftModifier + bigEndianMod * (byteOffset % 4))\n\t\t}\n\t\treturn {\n\t\t\tvalue: packed,\n\t\t\tbinLen: 8 * arr.byteLength + existingPackedLen\n\t\t}\n\t}\n\n\tfunction packed2hex(packed, outputLength, bigEndianMod, formatOpts) {\n\t\tvar i, srcByte, shiftModifier, hex_tab = \"0123456789abcdef\",\n\t\t\tstr = \"\",\n\t\t\tlength = outputLength / 8;\n\t\tshiftModifier = -1 === bigEndianMod ? 3 : 0;\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tsrcByte = packed[i >>> 2] >>> 8 * (shiftModifier + bigEndianMod * (i % 4));\n\t\t\tstr += hex_tab.charAt(srcByte >>> 4 & 15) + hex_tab.charAt(15 & srcByte)\n\t\t}\n\t\treturn formatOpts.outputUpper ? str.toUpperCase() : str\n\t}\n\n\tfunction packed2b64(packed, outputLength, bigEndianMod, formatOpts) {\n\t\tvar i, j, triplet, int1, int2, shiftModifier, str = \"\",\n\t\t\tlength = outputLength / 8,\n\t\t\tb64Tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\t\tshiftModifier = -1 === bigEndianMod ? 3 : 0;\n\t\tfor (i = 0; i < length; i += 3) {\n\t\t\tint1 = i + 1 < length ? packed[i + 1 >>> 2] : 0;\n\t\t\tint2 = i + 2 < length ? packed[i + 2 >>> 2] : 0;\n\t\t\ttriplet = (packed[i >>> 2] >>> 8 * (shiftModifier + bigEndianMod * (i % 4)) & 255) << 16 | (int1 >>> 8 * (shiftModifier + bigEndianMod * ((i + 1) % 4)) & 255) << 8 | int2 >>> 8 * (shiftModifier + bigEndianMod * ((i + 2) % 4)) & 255;\n\t\t\tfor (j = 0; j < 4; j += 1)\n\t\t\t\tif (8 * i + 6 * j <= outputLength) str += b64Tab.charAt(triplet >>> 6 * (3 - j) & 63);\n\t\t\t\telse str += formatOpts.b64Pad\n\t\t}\n\t\treturn str\n\t}\n\n\tfunction packed2bytes(packed, outputLength, bigEndianMod) {\n\t\tvar i, srcByte, shiftModifier, str = \"\",\n\t\t\tlength = outputLength / 8;\n\t\tshiftModifier = -1 === bigEndianMod ? 3 : 0;\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tsrcByte = packed[i >>> 2] >>> 8 * (shiftModifier + bigEndianMod * (i % 4)) & 255;\n\t\t\tstr += String.fromCharCode(srcByte)\n\t\t}\n\t\treturn str\n\t}\n\n\tfunction packed2arraybuffer(packed, outputLength, bigEndianMod) {\n\t\tvar i, shiftModifier, arrView, length = outputLength / 8,\n\t\t\tretVal = new ArrayBuffer(length);\n\t\tarrView = new Uint8Array(retVal);\n\t\tshiftModifier = -1 === bigEndianMod ? 3 : 0;\n\t\tfor (i = 0; i < length; i += 1) arrView[i] = packed[i >>> 2] >>> 8 * (shiftModifier + bigEndianMod * (i % 4)) & 255;\n\t\treturn retVal\n\t}\n\n\tfunction getOutputOpts(options) {\n\t\tvar outputOptions, retVal = {\n\t\t\toutputUpper: false,\n\t\t\tb64Pad: \"=\",\n\t\t\tshakeLen: -1\n\t\t};\n\t\toutputOptions = options || {};\n\t\tretVal.outputUpper = outputOptions.outputUpper || false;\n\t\tif (true === outputOptions.hasOwnProperty(\"b64Pad\")) retVal.b64Pad = outputOptions.b64Pad;\n\t\tif (true === outputOptions.hasOwnProperty(\"shakeLen\") && 0 !== (8 & SUPPORTED_ALGS)) {\n\t\t\tif (outputOptions.shakeLen % 8 !== 0) throw new Error(\"shakeLen must be a multiple of 8\");\n\t\t\tretVal.shakeLen = outputOptions.shakeLen\n\t\t}\n\t\tif (\"boolean\" !== typeof retVal.outputUpper) throw new Error(\"Invalid outputUpper formatting option\");\n\t\tif (\"string\" !== typeof retVal.b64Pad) throw new Error(\"Invalid b64Pad formatting option\");\n\t\treturn retVal\n\t}\n\n\tfunction getStrConverter(format, utfType, bigEndianMod) {\n\t\tvar retVal;\n\t\tswitch (utfType) {\n\t\tcase \"UTF8\":\n\t\tcase \"UTF16BE\":\n\t\tcase \"UTF16LE\":\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error(\"encoding must be UTF8, UTF16BE, or UTF16LE\")\n\t\t}\n\t\tswitch (format) {\n\t\tcase \"HEX\":\n\t\t\tretVal = function (str, existingBin, existingBinLen) {\n\t\t\t\treturn hex2packed(str, existingBin, existingBinLen, bigEndianMod)\n\t\t\t};\n\t\t\tbreak;\n\t\tcase \"TEXT\":\n\t\t\tretVal = function (str, existingBin, existingBinLen) {\n\t\t\t\treturn str2packed(str, utfType, existingBin, existingBinLen, bigEndianMod)\n\t\t\t};\n\t\t\tbreak;\n\t\tcase \"B64\":\n\t\t\tretVal = function (str, existingBin, existingBinLen) {\n\t\t\t\treturn b642packed(str, existingBin, existingBinLen, bigEndianMod)\n\t\t\t};\n\t\t\tbreak;\n\t\tcase \"BYTES\":\n\t\t\tretVal = function (str, existingBin, existingBinLen) {\n\t\t\t\treturn bytes2packed(str, existingBin, existingBinLen, bigEndianMod)\n\t\t\t};\n\t\t\tbreak;\n\t\tcase \"ARRAYBUFFER\":\n\t\t\ttry {\n\t\t\t\tretVal = new ArrayBuffer(0)\n\t\t\t} catch (ignore) {\n\t\t\t\tthrow new Error(\"ARRAYBUFFER not supported by this environment\")\n\t\t\t}\n\t\t\tretVal = function (arr, existingBin, existingBinLen) {\n\t\t\t\treturn arraybuffer2packed(arr, existingBin, existingBinLen, bigEndianMod)\n\t\t\t};\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error(\"format must be HEX, TEXT, B64, BYTES, or ARRAYBUFFER\")\n\t\t}\n\t\treturn retVal\n\t}\n\n\tfunction rotl_32(x, n) {\n\t\treturn x << n | x >>> 32 - n\n\t}\n\n\tfunction rotl_64(x, n) {\n\t\tif (n > 32) {\n\t\t\tn -= 32;\n\t\t\treturn new Int_64(x.lowOrder << n | x.highOrder >>> 32 - n, x.highOrder << n | x.lowOrder >>> 32 - n)\n\t\t} else if (0 !== n) return new Int_64(x.highOrder << n | x.lowOrder >>> 32 - n, x.lowOrder << n | x.highOrder >>> 32 - n);\n\t\telse return x\n\t}\n\n\tfunction rotr_32(x, n) {\n\t\treturn x >>> n | x << 32 - n\n\t}\n\n\tfunction rotr_64(x, n) {\n\t\tvar retVal = null,\n\t\t\ttmp = new Int_64(x.highOrder, x.lowOrder);\n\t\tif (32 >= n) retVal = new Int_64(tmp.highOrder >>> n | tmp.lowOrder << 32 - n & 4294967295, tmp.lowOrder >>> n | tmp.highOrder << 32 - n & 4294967295);\n\t\telse retVal = new Int_64(tmp.lowOrder >>> n - 32 | tmp.highOrder << 64 - n & 4294967295, tmp.highOrder >>> n - 32 | tmp.lowOrder << 64 - n & 4294967295);\n\t\treturn retVal\n\t}\n\n\tfunction shr_32(x, n) {\n\t\treturn x >>> n\n\t}\n\n\tfunction shr_64(x, n) {\n\t\tvar retVal = null;\n\t\tif (32 >= n) retVal = new Int_64(x.highOrder >>> n, x.lowOrder >>> n | x.highOrder << 32 - n & 4294967295);\n\t\telse retVal = new Int_64(0, x.highOrder >>> n - 32);\n\t\treturn retVal\n\t}\n\n\tfunction parity_32(x, y, z) {\n\t\treturn x ^ y ^ z\n\t}\n\n\tfunction ch_32(x, y, z) {\n\t\treturn x & y ^ ~x & z\n\t}\n\n\tfunction ch_64(x, y, z) {\n\t\treturn new Int_64(x.highOrder & y.highOrder ^ ~x.highOrder & z.highOrder, x.lowOrder & y.lowOrder ^ ~x.lowOrder & z.lowOrder)\n\t}\n\n\tfunction maj_32(x, y, z) {\n\t\treturn x & y ^ x & z ^ y & z\n\t}\n\n\tfunction maj_64(x, y, z) {\n\t\treturn new Int_64(x.highOrder & y.highOrder ^ x.highOrder & z.highOrder ^ y.highOrder & z.highOrder, x.lowOrder & y.lowOrder ^ x.lowOrder & z.lowOrder ^ y.lowOrder & z.lowOrder)\n\t}\n\n\tfunction sigma0_32(x) {\n\t\treturn rotr_32(x, 2) ^ rotr_32(x, 13) ^ rotr_32(x, 22)\n\t}\n\n\tfunction sigma0_64(x) {\n\t\tvar rotr28 = rotr_64(x, 28),\n\t\t\trotr34 = rotr_64(x, 34),\n\t\t\trotr39 = rotr_64(x, 39);\n\t\treturn new Int_64(rotr28.highOrder ^ rotr34.highOrder ^ rotr39.highOrder, rotr28.lowOrder ^ rotr34.lowOrder ^ rotr39.lowOrder)\n\t}\n\n\tfunction sigma1_32(x) {\n\t\treturn rotr_32(x, 6) ^ rotr_32(x, 11) ^ rotr_32(x, 25)\n\t}\n\n\tfunction sigma1_64(x) {\n\t\tvar rotr14 = rotr_64(x, 14),\n\t\t\trotr18 = rotr_64(x, 18),\n\t\t\trotr41 = rotr_64(x, 41);\n\t\treturn new Int_64(rotr14.highOrder ^ rotr18.highOrder ^ rotr41.highOrder, rotr14.lowOrder ^ rotr18.lowOrder ^ rotr41.lowOrder)\n\t}\n\n\tfunction gamma0_32(x) {\n\t\treturn rotr_32(x, 7) ^ rotr_32(x, 18) ^ shr_32(x, 3)\n\t}\n\n\tfunction gamma0_64(x) {\n\t\tvar rotr1 = rotr_64(x, 1),\n\t\t\trotr8 = rotr_64(x, 8),\n\t\t\tshr7 = shr_64(x, 7);\n\t\treturn new Int_64(rotr1.highOrder ^ rotr8.highOrder ^ shr7.highOrder, rotr1.lowOrder ^ rotr8.lowOrder ^ shr7.lowOrder)\n\t}\n\n\tfunction gamma1_32(x) {\n\t\treturn rotr_32(x, 17) ^ rotr_32(x, 19) ^ shr_32(x, 10)\n\t}\n\n\tfunction gamma1_64(x) {\n\t\tvar rotr19 = rotr_64(x, 19),\n\t\t\trotr61 = rotr_64(x, 61),\n\t\t\tshr6 = shr_64(x, 6);\n\t\treturn new Int_64(rotr19.highOrder ^ rotr61.highOrder ^ shr6.highOrder, rotr19.lowOrder ^ rotr61.lowOrder ^ shr6.lowOrder)\n\t}\n\n\tfunction safeAdd_32_2(a, b) {\n\t\tvar lsw = (65535 & a) + (65535 & b);\n\t\treturn (65535 & (a >>> 16) + (b >>> 16) + (lsw >>> 16)) << 16 | 65535 & lsw\n\t}\n\n\tfunction safeAdd_32_4(a, b, c, d) {\n\t\tvar lsw = (65535 & a) + (65535 & b) + (65535 & c) + (65535 & d);\n\t\treturn (65535 & (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) + (lsw >>> 16)) << 16 | 65535 & lsw\n\t}\n\n\tfunction safeAdd_32_5(a, b, c, d, e) {\n\t\tvar lsw = (65535 & a) + (65535 & b) + (65535 & c) + (65535 & d) + (65535 & e);\n\t\treturn (65535 & (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) + (e >>> 16) + (lsw >>> 16)) << 16 | 65535 & lsw\n\t}\n\n\tfunction safeAdd_64_2(x, y) {\n\t\tvar lsw, msw, lowOrder;\n\t\tlsw = (65535 & x.lowOrder) + (65535 & y.lowOrder);\n\t\tlowOrder = (65535 & (msw = (x.lowOrder >>> 16) + (y.lowOrder >>> 16) + (lsw >>> 16))) << 16 | 65535 & lsw;\n\t\tlsw = (65535 & x.highOrder) + (65535 & y.highOrder) + (msw >>> 16);\n\t\treturn new Int_64((65535 & (msw = (x.highOrder >>> 16) + (y.highOrder >>> 16) + (lsw >>> 16))) << 16 | 65535 & lsw, lowOrder)\n\t}\n\n\tfunction safeAdd_64_4(a, b, c, d) {\n\t\tvar lsw, msw, lowOrder;\n\t\tlsw = (65535 & a.lowOrder) + (65535 & b.lowOrder) + (65535 & c.lowOrder) + (65535 & d.lowOrder);\n\t\tlowOrder = (65535 & (msw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) + (c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (lsw >>> 16))) << 16 | 65535 & lsw;\n\t\tlsw = (65535 & a.highOrder) + (65535 & b.highOrder) + (65535 & c.highOrder) + (65535 & d.highOrder) + (msw >>> 16);\n\t\treturn new Int_64((65535 & (msw = (a.highOrder >>> 16) + (b.highOrder >>> 16) + (c.highOrder >>> 16) + (d.highOrder >>> 16) + (lsw >>> 16))) << 16 | 65535 & lsw, lowOrder)\n\t}\n\n\tfunction safeAdd_64_5(a, b, c, d, e) {\n\t\tvar lsw, msw, lowOrder;\n\t\tlsw = (65535 & a.lowOrder) + (65535 & b.lowOrder) + (65535 & c.lowOrder) + (65535 & d.lowOrder) + (65535 & e.lowOrder);\n\t\tlowOrder = (65535 & (msw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) + (c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (e.lowOrder >>> 16) + (lsw >>> 16))) << 16 | 65535 & lsw;\n\t\tlsw = (65535 & a.highOrder) + (65535 & b.highOrder) + (65535 & c.highOrder) + (65535 & d.highOrder) + (65535 & e.highOrder) + (msw >>> 16);\n\t\treturn new Int_64((65535 & (msw = (a.highOrder >>> 16) + (b.highOrder >>> 16) + (c.highOrder >>> 16) + (d.highOrder >>> 16) + (e.highOrder >>> 16) + (lsw >>> 16))) << 16 | 65535 & lsw, lowOrder)\n\t}\n\n\tfunction xor_64_2(a, b) {\n\t\treturn new Int_64(a.highOrder ^ b.highOrder, a.lowOrder ^ b.lowOrder)\n\t}\n\n\tfunction xor_64_5(a, b, c, d, e) {\n\t\treturn new Int_64(a.highOrder ^ b.highOrder ^ c.highOrder ^ d.highOrder ^ e.highOrder, a.lowOrder ^ b.lowOrder ^ c.lowOrder ^ d.lowOrder ^ e.lowOrder)\n\t}\n\n\tfunction cloneSHA3State(state) {\n\t\tvar i, clone = [];\n\t\tfor (i = 0; i < 5; i += 1) clone[i] = state[i].slice();\n\t\treturn clone\n\t}\n\n\tfunction getNewState(variant) {\n\t\tvar H_trunc, H_full, i, retVal = [];\n\t\tif (\"SHA-1\" === variant && 0 !== (1 & SUPPORTED_ALGS)) retVal = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];\n\t\telse if (0 === variant.lastIndexOf(\"SHA-\", 0) && 0 !== (6 & SUPPORTED_ALGS)) {\n\t\t\tH_trunc = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];\n\t\t\tH_full = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];\n\t\t\tswitch (variant) {\n\t\t\tcase \"SHA-224\":\n\t\t\t\tretVal = H_trunc;\n\t\t\t\tbreak;\n\t\t\tcase \"SHA-256\":\n\t\t\t\tretVal = H_full;\n\t\t\t\tbreak;\n\t\t\tcase \"SHA-384\":\n\t\t\t\tretVal = [new Int_64(3418070365, H_trunc[0]), new Int_64(1654270250, H_trunc[1]), new Int_64(2438529370, H_trunc[2]), new Int_64(355462360, H_trunc[3]), new Int_64(1731405415, H_trunc[4]), new Int_64(41048885895, H_trunc[5]), new Int_64(3675008525, H_trunc[6]), new Int_64(1203062813, H_trunc[7])];\n\t\t\t\tbreak;\n\t\t\tcase \"SHA-512\":\n\t\t\t\tretVal = [new Int_64(H_full[0], 4089235720), new Int_64(H_full[1], 2227873595), new Int_64(H_full[2], 4271175723), new Int_64(H_full[3], 1595750129), new Int_64(H_full[4], 2917565137), new Int_64(H_full[5], 725511199), new Int_64(H_full[6], 4215389547), new Int_64(H_full[7], 327033209)];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unknown SHA variant\")\n\t\t\t}\n\t\t} else if ((0 === variant.lastIndexOf(\"SHA3-\", 0) || 0 === variant.lastIndexOf(\"SHAKE\", 0)) && 0 !== (8 & SUPPORTED_ALGS))\n\t\t\tfor (i = 0; i < 5; i += 1) retVal[i] = [new Int_64(0, 0), new Int_64(0, 0), new Int_64(0, 0), new Int_64(0, 0), new Int_64(0, 0)];\n\t\telse throw new Error(\"No SHA variants supported\");\n\t\treturn retVal\n\t}\n\n\tfunction roundSHA1(block, H) {\n\t\tvar a, b, c, d, e, T, t, W = [],\n\t\t\tch = ch_32,\n\t\t\tparity = parity_32,\n\t\t\tmaj = maj_32,\n\t\t\trotl = rotl_32,\n\t\t\tsafeAdd_2 = safeAdd_32_2,\n\t\t\tsafeAdd_5 = safeAdd_32_5;\n\t\ta = H[0];\n\t\tb = H[1];\n\t\tc = H[2];\n\t\td = H[3];\n\t\te = H[4];\n\t\tfor (t = 0; t < 80; t += 1) {\n\t\t\tif (t < 16) W[t] = block[t];\n\t\t\telse W[t] = rotl(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n\t\t\tif (t < 20) T = safeAdd_5(rotl(a, 5), ch(b, c, d), e, 1518500249, W[t]);\n\t\t\telse if (t < 40) T = safeAdd_5(rotl(a, 5), parity(b, c, d), e, 1859775393, W[t]);\n\t\t\telse if (t < 60) T = safeAdd_5(rotl(a, 5), maj(b, c, d), e, 2400959708, W[t]);\n\t\t\telse T = safeAdd_5(rotl(a, 5), parity(b, c, d), e, 3395469782, W[t]);\n\t\t\te = d;\n\t\t\td = c;\n\t\t\tc = rotl(b, 30);\n\t\t\tb = a;\n\t\t\ta = T\n\t\t}\n\t\tH[0] = safeAdd_2(a, H[0]);\n\t\tH[1] = safeAdd_2(b, H[1]);\n\t\tH[2] = safeAdd_2(c, H[2]);\n\t\tH[3] = safeAdd_2(d, H[3]);\n\t\tH[4] = safeAdd_2(e, H[4]);\n\t\treturn H\n\t}\n\n\tfunction finalizeSHA1(remainder, remainderBinLen, processedBinLen, H, outputLen) {\n\t\tvar i, appendedMessageLength, offset, totalLen;\n\t\toffset = 15 + (remainderBinLen + 65 >>> 9 << 4);\n\t\twhile (remainder.length <= offset) remainder.push(0);\n\t\tremainder[remainderBinLen >>> 5] |= 128 << 24 - remainderBinLen % 32;\n\t\ttotalLen = remainderBinLen + processedBinLen;\n\t\tremainder[offset] = 4294967295 & totalLen;\n\t\tremainder[offset - 1] = totalLen / TWO_PWR_32 | 0;\n\t\tappendedMessageLength = remainder.length;\n\t\tfor (i = 0; i < appendedMessageLength; i += 16) H = roundSHA1(remainder.slice(i, i + 16), H);\n\t\treturn H\n\t}\n\n\tfunction roundSHA2(block, H, variant) {\n\t\tvar a, b, c, d, e, f, g, h, T1, T2, numRounds, t, binaryStringMult, safeAdd_2, safeAdd_4, safeAdd_5, gamma0, gamma1, sigma0, sigma1, ch, maj, Int, int1, int2, offset, K, W = [];\n\t\tif ((\"SHA-224\" === variant || \"SHA-256\" === variant) && 0 !== (2 & SUPPORTED_ALGS)) {\n\t\t\tnumRounds = 64;\n\t\t\tbinaryStringMult = 1;\n\t\t\tInt = Number;\n\t\t\tsafeAdd_2 = safeAdd_32_2;\n\t\t\tsafeAdd_4 = safeAdd_32_4;\n\t\t\tsafeAdd_5 = safeAdd_32_5;\n\t\t\tgamma0 = gamma0_32;\n\t\t\tgamma1 = gamma1_32;\n\t\t\tsigma0 = sigma0_32;\n\t\t\tsigma1 = sigma1_32;\n\t\t\tmaj = maj_32;\n\t\t\tch = ch_32;\n\t\t\tK = K_sha2\n\t\t} else if ((\"SHA-384\" === variant || \"SHA-512\" === variant) && 0 !== (4 & SUPPORTED_ALGS)) {\n\t\t\tnumRounds = 80;\n\t\t\tbinaryStringMult = 2;\n\t\t\tInt = Int_64;\n\t\t\tsafeAdd_2 = safeAdd_64_2;\n\t\t\tsafeAdd_4 = safeAdd_64_4;\n\t\t\tsafeAdd_5 = safeAdd_64_5;\n\t\t\tgamma0 = gamma0_64;\n\t\t\tgamma1 = gamma1_64;\n\t\t\tsigma0 = sigma0_64;\n\t\t\tsigma1 = sigma1_64;\n\t\t\tmaj = maj_64;\n\t\t\tch = ch_64;\n\t\t\tK = K_sha512\n\t\t} else throw new Error(\"Unexpected error in SHA-2 implementation\");\n\t\ta = H[0];\n\t\tb = H[1];\n\t\tc = H[2];\n\t\td = H[3];\n\t\te = H[4];\n\t\tf = H[5];\n\t\tg = H[6];\n\t\th = H[7];\n\t\tfor (t = 0; t < numRounds; t += 1) {\n\t\t\tif (t < 16) {\n\t\t\t\toffset = t * binaryStringMult;\n\t\t\t\tint1 = block.length <= offset ? 0 : block[offset];\n\t\t\t\tint2 = block.length <= offset + 1 ? 0 : block[offset + 1];\n\t\t\t\tW[t] = new Int(int1, int2)\n\t\t\t} else W[t] = safeAdd_4(gamma1(W[t - 2]), W[t - 7], gamma0(W[t - 15]), W[t - 16]);\n\t\t\tT1 = safeAdd_5(h, sigma1(e), ch(e, f, g), K[t], W[t]);\n\t\t\tT2 = safeAdd_2(sigma0(a), maj(a, b, c));\n\t\t\th = g;\n\t\t\tg = f;\n\t\t\tf = e;\n\t\t\te = safeAdd_2(d, T1);\n\t\t\td = c;\n\t\t\tc = b;\n\t\t\tb = a;\n\t\t\ta = safeAdd_2(T1, T2)\n\t\t}\n\t\tH[0] = safeAdd_2(a, H[0]);\n\t\tH[1] = safeAdd_2(b, H[1]);\n\t\tH[2] = safeAdd_2(c, H[2]);\n\t\tH[3] = safeAdd_2(d, H[3]);\n\t\tH[4] = safeAdd_2(e, H[4]);\n\t\tH[5] = safeAdd_2(f, H[5]);\n\t\tH[6] = safeAdd_2(g, H[6]);\n\t\tH[7] = safeAdd_2(h, H[7]);\n\t\treturn H\n\t}\n\n\tfunction finalizeSHA2(remainder, remainderBinLen, processedBinLen, H, variant, outputLen) {\n\t\tvar i, appendedMessageLength, offset, retVal, binaryStringInc, totalLen;\n\t\tif ((\"SHA-224\" === variant || \"SHA-256\" === variant) && 0 !== (2 & SUPPORTED_ALGS)) {\n\t\t\toffset = 15 + (remainderBinLen + 65 >>> 9 << 4);\n\t\t\tbinaryStringInc = 16\n\t\t} else if ((\"SHA-384\" === variant || \"SHA-512\" === variant) && 0 !== (4 & SUPPORTED_ALGS)) {\n\t\t\toffset = 31 + (remainderBinLen + 129 >>> 10 << 5);\n\t\t\tbinaryStringInc = 32\n\t\t} else throw new Error(\"Unexpected error in SHA-2 implementation\");\n\t\twhile (remainder.length <= offset) remainder.push(0);\n\t\tremainder[remainderBinLen >>> 5] |= 128 << 24 - remainderBinLen % 32;\n\t\ttotalLen = remainderBinLen + processedBinLen;\n\t\tremainder[offset] = 4294967295 & totalLen;\n\t\tremainder[offset - 1] = totalLen / TWO_PWR_32 | 0;\n\t\tappendedMessageLength = remainder.length;\n\t\tfor (i = 0; i < appendedMessageLength; i += binaryStringInc) H = roundSHA2(remainder.slice(i, i + binaryStringInc), H, variant);\n\t\tif (\"SHA-224\" === variant && 0 !== (2 & SUPPORTED_ALGS)) retVal = [H[0], H[1], H[2], H[3], H[4], H[5], H[6]];\n\t\telse if (\"SHA-256\" === variant && 0 !== (2 & SUPPORTED_ALGS)) retVal = H;\n\t\telse if (\"SHA-384\" === variant && 0 !== (4 & SUPPORTED_ALGS)) retVal = [H[0].highOrder, H[0].lowOrder, H[1].highOrder, H[1].lowOrder, H[2].highOrder, H[2].lowOrder, H[3].highOrder, H[3].lowOrder, H[4].highOrder, H[4].lowOrder, H[5].highOrder, H[5].lowOrder];\n\t\telse if (\"SHA-512\" === variant && 0 !== (4 & SUPPORTED_ALGS)) retVal = [H[0].highOrder, H[0].lowOrder, H[1].highOrder, H[1].lowOrder, H[2].highOrder, H[2].lowOrder, H[3].highOrder, H[3].lowOrder, H[4].highOrder, H[4].lowOrder, H[5].highOrder, H[5].lowOrder, H[6].highOrder, H[6].lowOrder, H[7].highOrder, H[7].lowOrder];\n\t\telse throw new Error(\"Unexpected error in SHA-2 implementation\");\n\t\treturn retVal\n\t}\n\n\tfunction roundSHA3(block, state) {\n\t\tvar round, x, y, B, C = [],\n\t\t\tD = [];\n\t\tif (null !== block)\n\t\t\tfor (x = 0; x < block.length; x += 2) state[(x >>> 1) % 5][(x >>> 1) / 5 | 0] = xor_64_2(state[(x >>> 1) % 5][(x >>> 1) / 5 | 0], new Int_64(block[x + 1], block[x]));\n\t\tfor (round = 0; round < 24; round += 1) {\n\t\t\tB = getNewState(\"SHA3-\");\n\t\t\tfor (x = 0; x < 5; x += 1) C[x] = xor_64_5(state[x][0], state[x][1], state[x][2], state[x][3], state[x][4]);\n\t\t\tfor (x = 0; x < 5; x += 1) D[x] = xor_64_2(C[(x + 4) % 5], rotl_64(C[(x + 1) % 5], 1));\n\t\t\tfor (x = 0; x < 5; x += 1)\n\t\t\t\tfor (y = 0; y < 5; y += 1) state[x][y] = xor_64_2(state[x][y], D[x]);\n\t\t\tfor (x = 0; x < 5; x += 1)\n\t\t\t\tfor (y = 0; y < 5; y += 1) B[y][(2 * x + 3 * y) % 5] = rotl_64(state[x][y], r_sha3[x][y]);\n\t\t\tfor (x = 0; x < 5; x += 1)\n\t\t\t\tfor (y = 0; y < 5; y += 1) state[x][y] = xor_64_2(B[x][y], new Int_64(~B[(x + 1) % 5][y].highOrder & B[(x + 2) % 5][y].highOrder, ~B[(x + 1) % 5][y].lowOrder & B[(x + 2) % 5][y].lowOrder));\n\t\t\tstate[0][0] = xor_64_2(state[0][0], rc_sha3[round])\n\t\t}\n\t\treturn state\n\t}\n\n\tfunction finalizeSHA3(remainder, remainderBinLen, processedBinLen, state, blockSize, delimiter, outputLen) {\n\t\tvar i, temp, retVal = [],\n\t\t\tbinaryStringInc = blockSize >>> 5,\n\t\t\tstate_offset = 0,\n\t\t\tremainderIntLen = remainderBinLen >>> 5;\n\t\tfor (i = 0; i < remainderIntLen && remainderBinLen >= blockSize; i += binaryStringInc) {\n\t\t\tstate = roundSHA3(remainder.slice(i, i + binaryStringInc), state);\n\t\t\tremainderBinLen -= blockSize\n\t\t}\n\t\tremainder = remainder.slice(i);\n\t\tremainderBinLen %= blockSize;\n\t\twhile (remainder.length < binaryStringInc) remainder.push(0);\n\t\tremainder[(i = remainderBinLen >>> 3) >> 2] ^= delimiter << i % 4 * 8;\n\t\tremainder[binaryStringInc - 1] ^= 2147483648;\n\t\tstate = roundSHA3(remainder, state);\n\t\twhile (32 * retVal.length < outputLen) {\n\t\t\ttemp = state[state_offset % 5][state_offset / 5 | 0];\n\t\t\tretVal.push(temp.lowOrder);\n\t\t\tif (32 * retVal.length >= outputLen) break;\n\t\t\tretVal.push(temp.highOrder);\n\t\t\tif (0 === 64 * (state_offset += 1) % blockSize) roundSHA3(null, state)\n\t\t}\n\t\treturn retVal\n\t}\n\tvar K_sha2, K_sha512, r_sha3, rc_sha3, jsSHA, TWO_PWR_32 = 4294967296;\n\tif (0 !== (6 & SUPPORTED_ALGS)) {\n\t\tK_sha2 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];\n\t\tif (0 !== (4 & SUPPORTED_ALGS)) K_sha512 = [new Int_64(K_sha2[0], 3609767458), new Int_64(K_sha2[1], 602891725), new Int_64(K_sha2[2], 3964484399), new Int_64(K_sha2[3], 2173295548), new Int_64(K_sha2[4], 4081628472), new Int_64(K_sha2[5], 3053834265), new Int_64(K_sha2[6], 2937671579), new Int_64(K_sha2[7], 3664609560), new Int_64(K_sha2[8], 2734883394), new Int_64(K_sha2[9], 1164996542), new Int_64(K_sha2[10], 1323610764), new Int_64(K_sha2[11], 3590304994), new Int_64(K_sha2[12], 4068182383), new Int_64(K_sha2[13], 991336113), new Int_64(K_sha2[14], 633803317), new Int_64(K_sha2[15], 3479774868), new Int_64(K_sha2[16], 2666613458), new Int_64(K_sha2[17], 944711139), new Int_64(K_sha2[18], 2341262773), new Int_64(K_sha2[19], 2007800933), new Int_64(K_sha2[20], 1495990901), new Int_64(K_sha2[21], 1856431235), new Int_64(K_sha2[22], 3175218132), new Int_64(K_sha2[23], 2198950837), new Int_64(K_sha2[24], 3999719339), new Int_64(K_sha2[25], 766784016), new Int_64(K_sha2[26], 2566594879), new Int_64(K_sha2[27], 3203337956), new Int_64(K_sha2[28], 1034457026), new Int_64(K_sha2[29], 2466948901), new Int_64(K_sha2[30], 3758326383), new Int_64(K_sha2[31], 168717936), new Int_64(K_sha2[32], 1188179964), new Int_64(K_sha2[33], 1546045734), new Int_64(K_sha2[34], 1522805485), new Int_64(K_sha2[35], 2643833823), new Int_64(K_sha2[36], 2343527390), new Int_64(K_sha2[37], 1014477480), new Int_64(K_sha2[38], 1206759142), new Int_64(K_sha2[39], 344077627), new Int_64(K_sha2[40], 1290863460), new Int_64(K_sha2[41], 3158454273), new Int_64(K_sha2[42], 3505952657), new Int_64(K_sha2[43], 106217008), new Int_64(K_sha2[44], 3606008344), new Int_64(K_sha2[45], 1432725776), new Int_64(K_sha2[46], 1467031594), new Int_64(K_sha2[47], 851169720), new Int_64(K_sha2[48], 3100823752), new Int_64(K_sha2[49], 1363258195), new Int_64(K_sha2[50], 3750685593), new Int_64(K_sha2[51], 3785050280), new Int_64(K_sha2[52], 3318307427), new Int_64(K_sha2[53], 3812723403), new Int_64(K_sha2[54], 2003034995), new Int_64(K_sha2[55], 3602036899), new Int_64(K_sha2[56], 1575990012), new Int_64(K_sha2[57], 1125592928), new Int_64(K_sha2[58], 2716904306), new Int_64(K_sha2[59], 442776044), new Int_64(K_sha2[60], 593698344), new Int_64(K_sha2[61], 3733110249), new Int_64(K_sha2[62], 2999351573), new Int_64(K_sha2[63], 3815920427), new Int_64(3391569614, 3928383900), new Int_64(3515267271, 566280711), new Int_64(3940187606, 3454069534), new Int_64(4118630271, 4000239992), new Int_64(116418474, 1914138554), new Int_64(174292421, 2731055270), new Int_64(289380356, 3203993006), new Int_64(460393269, 320620315), new Int_64(685471733, 587496836), new Int_64(852142971, 1086792851), new Int_64(1017036298, 365543100), new Int_64(1126000580, 2618297676), new Int_64(1288033470, 3409855158), new Int_64(1501505948, 4234509866), new Int_64(1607167915, 987167468), new Int_64(1816402316, 1246189591)]\n\t}\n\tif (0 !== (8 & SUPPORTED_ALGS)) {\n\t\trc_sha3 = [new Int_64(0, 1), new Int_64(0, 32898), new Int_64(2147483648, 32906), new Int_64(2147483648, 2147516416), new Int_64(0, 32907), new Int_64(0, 2147483649), new Int_64(2147483648, 2147516545), new Int_64(2147483648, 32777), new Int_64(0, 138), new Int_64(0, 136), new Int_64(0, 2147516425), new Int_64(0, 2147483658), new Int_64(0, 2147516555), new Int_64(2147483648, 139), new Int_64(2147483648, 32905), new Int_64(2147483648, 32771), new Int_64(2147483648, 32770), new Int_64(2147483648, 128), new Int_64(0, 32778), new Int_64(2147483648, 2147483658), new Int_64(2147483648, 2147516545), new Int_64(2147483648, 32896), new Int_64(0, 2147483649), new Int_64(2147483648, 2147516424)];\n\t\tr_sha3 = [\n\t\t\t[0, 36, 3, 41, 18],\n\t\t\t[1, 44, 10, 45, 2],\n\t\t\t[62, 6, 43, 15, 61],\n\t\t\t[28, 55, 25, 21, 56],\n\t\t\t[27, 20, 39, 8, 14]\n\t\t]\n\t}\n\tjsSHA = function (variant, inputFormat, options) {\n\t\tvar intermediateState, converterFunc, outputBinLen, variantBlockSize, roundFunc, finalizeFunc, stateCloneFunc, delimiter, processedLen = 0,\n\t\t\tremainder = [],\n\t\t\tremainderLen = 0,\n\t\t\tshaVariant = variant,\n\t\t\thmacKeySet = false,\n\t\t\tkeyWithIPad = [],\n\t\t\tkeyWithOPad = [],\n\t\t\tupdatedCalled = false,\n\t\t\tisSHAKE = false,\n\t\t\tbigEndianMod = -1,\n\t\t\tinputOptions = options || {},\n\t\t\tutfType = inputOptions.encoding || \"UTF8\",\n\t\t\tnumRounds = inputOptions.numRounds || 1;\n\t\tif (numRounds !== parseInt(numRounds, 10) || 1 > numRounds) throw new Error(\"numRounds must a integer >= 1\");\n\t\tif (\"SHA-1\" === shaVariant && 0 !== (1 & SUPPORTED_ALGS)) {\n\t\t\tvariantBlockSize = 512;\n\t\t\troundFunc = roundSHA1;\n\t\t\tfinalizeFunc = finalizeSHA1;\n\t\t\toutputBinLen = 160;\n\t\t\tstateCloneFunc = function (state) {\n\t\t\t\treturn state.slice()\n\t\t\t}\n\t\t} else if (0 === shaVariant.lastIndexOf(\"SHA-\", 0) && 0 !== (6 & SUPPORTED_ALGS)) {\n\t\t\troundFunc = function (block, H) {\n\t\t\t\treturn roundSHA2(block, H, shaVariant)\n\t\t\t};\n\t\t\tfinalizeFunc = function (remainder, remainderBinLen, processedBinLen, H, outputLen) {\n\t\t\t\treturn finalizeSHA2(remainder, remainderBinLen, processedBinLen, H, shaVariant, outputLen)\n\t\t\t};\n\t\t\tstateCloneFunc = function (state) {\n\t\t\t\treturn state.slice()\n\t\t\t};\n\t\t\tif (\"SHA-224\" === shaVariant && 0 !== (2 & SUPPORTED_ALGS)) {\n\t\t\t\tvariantBlockSize = 512;\n\t\t\t\toutputBinLen = 224\n\t\t\t} else if (\"SHA-256\" === shaVariant && 0 !== (2 & SUPPORTED_ALGS)) {\n\t\t\t\tvariantBlockSize = 512;\n\t\t\t\toutputBinLen = 256\n\t\t\t} else if (\"SHA-384\" === shaVariant && 0 !== (4 & SUPPORTED_ALGS)) {\n\t\t\t\tvariantBlockSize = 1024;\n\t\t\t\toutputBinLen = 384\n\t\t\t} else if (\"SHA-512\" === shaVariant && 0 !== (4 & SUPPORTED_ALGS)) {\n\t\t\t\tvariantBlockSize = 1024;\n\t\t\t\toutputBinLen = 512\n\t\t\t} else throw new Error(\"Chosen SHA variant is not supported\")\n\t\t} else if ((0 === shaVariant.lastIndexOf(\"SHA3-\", 0) || 0 === shaVariant.lastIndexOf(\"SHAKE\", 0)) && 0 !== (8 & SUPPORTED_ALGS)) {\n\t\t\tdelimiter = 6;\n\t\t\troundFunc = roundSHA3;\n\t\t\tstateCloneFunc = function (state) {\n\t\t\t\treturn cloneSHA3State(state)\n\t\t\t};\n\t\t\tbigEndianMod = 1;\n\t\t\tif (\"SHA3-224\" === shaVariant) {\n\t\t\t\tvariantBlockSize = 1152;\n\t\t\t\toutputBinLen = 224\n\t\t\t} else if (\"SHA3-256\" === shaVariant) {\n\t\t\t\tvariantBlockSize = 1088;\n\t\t\t\toutputBinLen = 256\n\t\t\t} else if (\"SHA3-384\" === shaVariant) {\n\t\t\t\tvariantBlockSize = 832;\n\t\t\t\toutputBinLen = 384\n\t\t\t} else if (\"SHA3-512\" === shaVariant) {\n\t\t\t\tvariantBlockSize = 576;\n\t\t\t\toutputBinLen = 512\n\t\t\t} else if (\"SHAKE128\" === shaVariant) {\n\t\t\t\tvariantBlockSize = 1344;\n\t\t\t\toutputBinLen = -1;\n\t\t\t\tdelimiter = 31;\n\t\t\t\tisSHAKE = true\n\t\t\t} else if (\"SHAKE256\" === shaVariant) {\n\t\t\t\tvariantBlockSize = 1088;\n\t\t\t\toutputBinLen = -1;\n\t\t\t\tdelimiter = 31;\n\t\t\t\tisSHAKE = true\n\t\t\t} else throw new Error(\"Chosen SHA variant is not supported\");\n\t\t\tfinalizeFunc = function (remainder, remainderBinLen, processedBinLen, state, outputLen) {\n\t\t\t\treturn finalizeSHA3(remainder, remainderBinLen, processedBinLen, state, variantBlockSize, delimiter, outputLen)\n\t\t\t}\n\t\t} else throw new Error(\"Chosen SHA variant is not supported\");\n\t\tconverterFunc = getStrConverter(inputFormat, utfType, bigEndianMod);\n\t\tintermediateState = getNewState(shaVariant);\n\t\tthis.setHMACKey = function (key, inputFormat, options) {\n\t\t\tvar convertRet, keyBinLen, keyToUse, blockByteSize, i, lastArrayIndex;\n\t\t\tif (true === hmacKeySet) throw new Error(\"HMAC key already set\");\n\t\t\tif (true === updatedCalled) throw new Error(\"Cannot set HMAC key after calling update\");\n\t\t\tif (true === isSHAKE && 0 !== (8 & SUPPORTED_ALGS)) throw new Error(\"SHAKE is not supported for HMAC\");\n\t\t\tkeyBinLen = (convertRet = getStrConverter(inputFormat, utfType = (options || {})\n\t\t\t\t\t.encoding || \"UTF8\", bigEndianMod)(key))\n\t\t\t\t.binLen;\n\t\t\tkeyToUse = convertRet.value;\n\t\t\tlastArrayIndex = (blockByteSize = variantBlockSize >>> 3) / 4 - 1;\n\t\t\tif (blockByteSize < keyBinLen / 8) {\n\t\t\t\tkeyToUse = finalizeFunc(keyToUse, keyBinLen, 0, getNewState(shaVariant), outputBinLen);\n\t\t\t\twhile (keyToUse.length <= lastArrayIndex) keyToUse.push(0);\n\t\t\t\tkeyToUse[lastArrayIndex] &= 4294967040\n\t\t\t} else if (blockByteSize > keyBinLen / 8) {\n\t\t\t\twhile (keyToUse.length <= lastArrayIndex) keyToUse.push(0);\n\t\t\t\tkeyToUse[lastArrayIndex] &= 4294967040\n\t\t\t}\n\t\t\tfor (i = 0; i <= lastArrayIndex; i += 1) {\n\t\t\t\tkeyWithIPad[i] = 909522486 ^ keyToUse[i];\n\t\t\t\tkeyWithOPad[i] = 1549556828 ^ keyToUse[i]\n\t\t\t}\n\t\t\tintermediateState = roundFunc(keyWithIPad, intermediateState);\n\t\t\tprocessedLen = variantBlockSize;\n\t\t\thmacKeySet = true\n\t\t};\n\t\tthis.update = function (srcString) {\n\t\t\tvar convertRet, chunkBinLen, chunkIntLen, chunk, i, updateProcessedLen = 0,\n\t\t\t\tvariantBlockIntInc = variantBlockSize >>> 5;\n\t\t\tchunkBinLen = (convertRet = converterFunc(srcString, remainder, remainderLen))\n\t\t\t\t.binLen;\n\t\t\tchunk = convertRet.value;\n\t\t\tchunkIntLen = chunkBinLen >>> 5;\n\t\t\tfor (i = 0; i < chunkIntLen; i += variantBlockIntInc)\n\t\t\t\tif (updateProcessedLen + variantBlockSize <= chunkBinLen) {\n\t\t\t\t\tintermediateState = roundFunc(chunk.slice(i, i + variantBlockIntInc), intermediateState);\n\t\t\t\t\tupdateProcessedLen += variantBlockSize\n\t\t\t\t}\n\t\t\tprocessedLen += updateProcessedLen;\n\t\t\tremainder = chunk.slice(updateProcessedLen >>> 5);\n\t\t\tremainderLen = chunkBinLen % variantBlockSize;\n\t\t\tupdatedCalled = true\n\t\t};\n\t\tthis.getHash = function (format, options) {\n\t\t\tvar formatFunc, i, outputOptions, finalizedState;\n\t\t\tif (true === hmacKeySet) throw new Error(\"Cannot call getHash after setting HMAC key\");\n\t\t\toutputOptions = getOutputOpts(options);\n\t\t\tif (true === isSHAKE && 0 !== (8 & SUPPORTED_ALGS)) {\n\t\t\t\tif (-1 === outputOptions.shakeLen) throw new Error(\"shakeLen must be specified in options\");\n\t\t\t\toutputBinLen = outputOptions.shakeLen\n\t\t\t}\n\t\t\tswitch (format) {\n\t\t\tcase \"HEX\":\n\t\t\t\tformatFunc = function (binarray) {\n\t\t\t\t\treturn packed2hex(binarray, outputBinLen, bigEndianMod, outputOptions)\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase \"B64\":\n\t\t\t\tformatFunc = function (binarray) {\n\t\t\t\t\treturn packed2b64(binarray, outputBinLen, bigEndianMod, outputOptions)\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase \"BYTES\":\n\t\t\t\tformatFunc = function (binarray) {\n\t\t\t\t\treturn packed2bytes(binarray, outputBinLen, bigEndianMod)\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase \"ARRAYBUFFER\":\n\t\t\t\ttry {\n\t\t\t\t\ti = new ArrayBuffer(0)\n\t\t\t\t} catch (ignore) {\n\t\t\t\t\tthrow new Error(\"ARRAYBUFFER not supported by this environment\")\n\t\t\t\t}\n\t\t\t\tformatFunc = function (binarray) {\n\t\t\t\t\treturn packed2arraybuffer(binarray, outputBinLen, bigEndianMod)\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"format must be HEX, B64, BYTES, or ARRAYBUFFER\")\n\t\t\t}\n\t\t\tfinalizedState = finalizeFunc(remainder.slice(), remainderLen, processedLen, stateCloneFunc(intermediateState), outputBinLen);\n\t\t\tfor (i = 1; i < numRounds; i += 1) {\n\t\t\t\tif (0 !== (8 & SUPPORTED_ALGS) && true === isSHAKE && outputBinLen % 32 !== 0) finalizedState[finalizedState.length - 1] &= 16777215 >>> 24 - outputBinLen % 32;\n\t\t\t\tfinalizedState = finalizeFunc(finalizedState, outputBinLen, 0, getNewState(shaVariant), outputBinLen)\n\t\t\t}\n\t\t\treturn formatFunc(finalizedState)\n\t\t};\n\t\tthis.getHMAC = function (format, options) {\n\t\t\tvar formatFunc, firstHash, outputOptions, finalizedState;\n\t\t\tif (false === hmacKeySet) throw new Error(\"Cannot call getHMAC without first setting HMAC key\");\n\t\t\toutputOptions = getOutputOpts(options);\n\t\t\tswitch (format) {\n\t\t\tcase \"HEX\":\n\t\t\t\tformatFunc = function (binarray) {\n\t\t\t\t\treturn packed2hex(binarray, outputBinLen, bigEndianMod, outputOptions)\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase \"B64\":\n\t\t\t\tformatFunc = function (binarray) {\n\t\t\t\t\treturn packed2b64(binarray, outputBinLen, bigEndianMod, outputOptions)\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase \"BYTES\":\n\t\t\t\tformatFunc = function (binarray) {\n\t\t\t\t\treturn packed2bytes(binarray, outputBinLen, bigEndianMod)\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase \"ARRAYBUFFER\":\n\t\t\t\ttry {\n\t\t\t\t\tformatFunc = new ArrayBuffer(0)\n\t\t\t\t} catch (ignore) {\n\t\t\t\t\tthrow new Error(\"ARRAYBUFFER not supported by this environment\")\n\t\t\t\t}\n\t\t\t\tformatFunc = function (binarray) {\n\t\t\t\t\treturn packed2arraybuffer(binarray, outputBinLen, bigEndianMod)\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"outputFormat must be HEX, B64, BYTES, or ARRAYBUFFER\")\n\t\t\t}\n\t\t\tfirstHash = finalizeFunc(remainder.slice(), remainderLen, processedLen, stateCloneFunc(intermediateState), outputBinLen);\n\t\t\tfinalizedState = roundFunc(keyWithOPad, getNewState(shaVariant));\n\t\t\treturn formatFunc(finalizedState = finalizeFunc(firstHash, outputBinLen, variantBlockSize, finalizedState, outputBinLen))\n\t\t}\n\t};\n\tif (\"function\" === typeof define && define.amd) define(function () {\n\t\treturn jsSHA\n\t});\n\telse if (\"undefined\" !== typeof exports)\n\t\tif (\"undefined\" !== typeof module && module.exports) {\n\t\t\tmodule.exports = jsSHA;\n\t\t\texports = jsSHA\n\t\t} else exports = jsSHA;\n\telse global.jsSHA = jsSHA\n})(this);\n(function (global) {\n\t\"use strict\";\n\n\tfunction definition(path, Failure, iterate, isObject) {\n\t\tfunction isEnabled(path) {\n\t\t\tvar match;\n\t\t\titerate(settings, function (key, value) {\n\t\t\t\tif (key === path) {\n\t\t\t\t\tmatch = value;\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn match || false\n\t\t}\n\t\tvar settings;\n\t\tdemand.on(\"postConfigure:\" + path, function (options) {\n\t\t\t\tif (isObject(options)) settings = options\n\t\t\t})\n\t\t\t.on(\"postRequest\", function (dependency) {\n\t\t\t\tvar options, sha, hash;\n\t\t\t\tif (options = isEnabled(dependency.path)) try {\n\t\t\t\t\t(sha = new global.jsSHA(options.type, \"TEXT\"))\n\t\t\t\t\t.update(dependency.source);\n\t\t\t\t\tif ((hash = sha.getHash(\"B64\")) !== options.hash) dependency.dfd.reject(new Failure('hash mismatch, should be \"' + options.hash + '\" but is \"' + hash + '\" (sri)', dependency.id))\n\t\t\t\t} catch (error) {\n\t\t\t\t\tdependency.dfd.reject(new Failure(\"unsupported hashing algorithm (sri)\", dependency.id))\n\t\t\t\t}\n\t\t\t});\n\t\treturn true\n\t}\n\tprovide([\"path\", \"/demand/failure\", \"/demand/function/iterate\", \"/demand/validator/isObject\"], definition)\n})(this);\n"]}