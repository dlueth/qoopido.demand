{"version":3,"sources":["../vendor/jssha/src/sha_dev.js"],"names":["SUPPORTED_ALGS","global","K_sha2","K_sha512","r_sha3","rc_sha3","TWO_PWR_32","Int_64","msint_32","lsint_32","this","highOrder","lowOrder","packed2hex","packed","outputLength","bigEndianMod","formatOpts","i","srcByte","shiftModifier","hex_tab","str","length","charAt","toUpperCase","packed2b64","j","triplet","int1","int2","packed2bytes","String","fromCharCode","packed2arraybuffer","arrView","retVal","ArrayBuffer","Uint8Array","getOutputOpts","options","outputOptions","outputUpper","b64Pad","shakeLen","hasOwnProperty","Error","getStrConverter","format","utfType","existingBin","existingBinLen","existingPacked","existingPackedLen","num","intOffset","byteOffset","existingByteLen","parseInt","substr","isNaN","push","value","binLen","hex2packed","codePnt","codePntArr","transposeBytes","byteCnt","charCodeAt","str2packed","tmpInt","strPart","firstEqual","search","indexOf","replace","b642packed","bytes2packed","ignore","arr","byteLength","arraybuffer2packed","rotl_32","x","n","rotl_64","rotr_32","rotr_64","tmp","shr_32","shr_64","parity_32","y","z","ch_32","ch_64","maj_32","maj_64","sigma0_32","sigma0_64","rotr28","rotr34","rotr39","sigma1_32","sigma1_64","rotr14","rotr18","rotr41","gamma0_32","gamma0_64","rotr1","rotr8","shr7","gamma1_32","gamma1_64","rotr19","rotr61","shr6","safeAdd_32_2","a","b","lsw","safeAdd_32_4","c","d","safeAdd_32_5","e","safeAdd_64_2","msw","safeAdd_64_4","safeAdd_64_5","xor_64_2","getNewState","variant","H_trunc","H_full","lastIndexOf","roundSHA1","block","H","T","t","W","ch","parity","maj","rotl","safeAdd_2","safeAdd_5","finalizeSHA1","remainder","remainderBinLen","processedBinLen","outputLen","appendedMessageLength","offset","totalLen","slice","roundSHA2","f","g","h","T1","T2","numRounds","binaryStringMult","safeAdd_4","gamma0","gamma1","sigma0","sigma1","Int","K","Number","roundSHA3","state","round","B","C","D","jsSHA","inputFormat","intermediateState","converterFunc","outputBinLen","variantBlockSize","roundFunc","finalizeFunc","stateCloneFunc","inputOptions","processedLen","remainderLen","shaVariant","hmacKeySet","keyWithIPad","keyWithOPad","updatedCalled","isSHAKE","binaryStringInc","finalizeSHA2","delimiter","clone","cloneSHA3State","blockSize","temp","state_offset","remainderIntLen","finalizeSHA3","setHMACKey","key","convertRet","keyBinLen","keyToUse","blockByteSize","lastArrayIndex","keyConverterFunc","update","srcString","chunkBinLen","chunkIntLen","chunk","updateProcessedLen","variantBlockIntInc","getHash","formatFunc","finalizedState","binarray","getHMAC","firstHash","define","exports","module","provide","path","Failure","iterate","isObject","settings","demand","on","dependency","sha","hash","match","type","source","dfd","reject","id","error"],"mappings":"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A,IAAAK,EAAAL,EAAA,GAAA,YAAA,IAAAK,EAAAL,EAAA,GAAA,YACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,YACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,WACA,IAAAK,EAAAL,EAAA,IAAA,WAAA,IAAAK,EAAAL,EAAA,IAAA,YACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,WACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,YACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,YACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,YACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,WACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,YACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,YACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,WACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,YACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,YACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,YACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,WACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,YACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,WACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,YACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,WACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,YACA,IAAAK,EAAAL,EAAA,IAAA,YAAA,IAAAK,EAAAL,EAAA,IAAA,YACA,IAAAK,EAAA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","file":"sri.js","sourcesContent":["/**\n * @preserve A JavaScript implementation of the SHA family of hashes, as\n * defined in FIPS PUB 180-4 and FIPS PUB 202, as well as the corresponding\n * HMAC implementation as defined in FIPS PUB 198a\n *\n * Copyright Brian Turek 2008-2017\n * Distributed under the BSD License\n * See http://caligatio.github.com/jsSHA/ for more information\n *\n * Several functions taken from Paul Johnston\n */\n\n/*jslint\n\tbitwise: true, multivar: true, for: true, this: true, sub: true, esversion: 3\n*/\n\n /**\n  * SUPPORTED_ALGS is the stub for a compile flag that will cause pruning of\n  * functions that are not needed when a limited number of SHA families are\n  * selected\n  *\n  * @define {number} ORed value of SHA variants to be supported\n  *   1 = SHA-1, 2 = SHA-224/SHA-256, 4 = SHA-384/SHA-512, 8 = SHA3\n  */\nvar SUPPORTED_ALGS = 8 | 4 | 2 | 1;\n\n(function (global)\n{\n\t\"use strict\";\n\n\t/* Globals */\n\tvar TWO_PWR_32 = 4294967296;\n\n\t/**\n\t * Int_64 is a object for 2 32-bit numbers emulating a 64-bit number\n\t *\n\t * @private\n\t * @constructor\n\t * @this {Int_64}\n\t * @param {number} msint_32 The most significant 32-bits of a 64-bit number\n\t * @param {number} lsint_32 The least significant 32-bits of a 64-bit number\n\t */\n\tfunction Int_64(msint_32, lsint_32)\n\t{\n\t\tthis.highOrder = msint_32;\n\t\tthis.lowOrder = lsint_32;\n\t}\n\n\t/**\n\t * Convert a string to an array of big-endian words\n\t *\n\t * There is a known bug with an odd number of existing bytes and using a\n\t * UTF-16 encoding.  However, this function is used such that the existing\n\t * bytes are always a result of a previous UTF-16 str2packed call and\n\t * therefore there should never be an odd number of existing bytes\n\t *\n\t * @private\n\t * @param {string} str String to be converted to binary representation\n\t * @param {string} utfType The Unicode type, UTF8 or UTF16BE, UTF16LE, to\n\t *   use to encode the source string\n\t * @param {Array<number>} existingPacked A packed int array of bytes to\n\t *   append the results to\n\t * @param {number} existingPackedLen The number of bits in the existingPacked\n\t *   array\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t *   length of \"value\"\n\t */\n\tfunction str2packed(str, utfType, existingPacked, existingPackedLen, bigEndianMod)\n\t{\n\t\tvar packed, codePnt, codePntArr, byteCnt = 0, i, j, existingByteLen,\n\t\t\tintOffset, byteOffset, shiftModifier, transposeBytes;\n\n\t\tpacked = existingPacked || [0];\n\t\texistingPackedLen = existingPackedLen || 0;\n\t\texistingByteLen = existingPackedLen >>> 3;\n\n\t\tif (\"UTF8\" === utfType)\n\t\t{\n\t\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\t\t\tfor (i = 0; i < str.length; i += 1)\n\t\t\t{\n\t\t\t\tcodePnt = str.charCodeAt(i);\n\t\t\t\tcodePntArr = [];\n\n\t\t\t\tif (0x80 > codePnt)\n\t\t\t\t{\n\t\t\t\t\tcodePntArr.push(codePnt);\n\t\t\t\t}\n\t\t\t\telse if (0x800 > codePnt)\n\t\t\t\t{\n\t\t\t\t\tcodePntArr.push(0xC0 | (codePnt >>> 6));\n\t\t\t\t\tcodePntArr.push(0x80 | (codePnt & 0x3F));\n\t\t\t\t}\n\t\t\t\telse if ((0xd800 > codePnt) || (0xe000 <= codePnt)) {\n\t\t\t\t\tcodePntArr.push(\n\t\t\t\t\t\t0xe0 | (codePnt >>> 12),\n\t\t\t\t\t\t0x80 | ((codePnt >>> 6) & 0x3f),\n\t\t\t\t\t\t0x80 | (codePnt & 0x3f)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ti += 1;\n\t\t\t\t\tcodePnt = 0x10000 + (((codePnt & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n\t\t\t\t\tcodePntArr.push(\n\t\t\t\t\t\t0xf0 | (codePnt >>> 18),\n\t\t\t\t\t\t0x80 | ((codePnt >>> 12) & 0x3f),\n\t\t\t\t\t\t0x80 | ((codePnt >>> 6) & 0x3f),\n\t\t\t\t\t\t0x80 | (codePnt & 0x3f)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tfor (j = 0; j < codePntArr.length; j += 1)\n\t\t\t\t{\n\t\t\t\t\tbyteOffset = byteCnt + existingByteLen;\n\t\t\t\t\tintOffset = byteOffset >>> 2;\n\t\t\t\t\twhile (packed.length <= intOffset)\n\t\t\t\t\t{\n\t\t\t\t\t\tpacked.push(0);\n\t\t\t\t\t}\n\t\t\t\t\t/* Known bug kicks in here */\n\t\t\t\t\tpacked[intOffset] |= codePntArr[j] << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n\t\t\t\t\tbyteCnt += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((\"UTF16BE\" === utfType) || \"UTF16LE\" === utfType)\n\t\t{\n\t\t\tshiftModifier = (bigEndianMod === -1) ? 2 : 0;\n\t\t\t/* Internally strings are UTF-16BE so transpose bytes under two conditions:\n\t\t\t\t* need LE and not switching endianness due to SHA-3\n\t\t\t\t* need BE and switching endianness due to SHA-3 */\n\t\t\ttransposeBytes = ((\"UTF16LE\" === utfType) && (bigEndianMod !== 1)) || ((\"UTF16LE\" !== utfType) && (bigEndianMod === 1));\n\t\t\tfor (i = 0; i < str.length; i += 1)\n\t\t\t{\n\t\t\t\tcodePnt = str.charCodeAt(i);\n\t\t\t\tif (transposeBytes === true)\n\t\t\t\t{\n\t\t\t\t\tj = codePnt & 0xFF;\n\t\t\t\t\tcodePnt = (j << 8) | (codePnt >>> 8);\n\t\t\t\t}\n\n\t\t\t\tbyteOffset = byteCnt + existingByteLen;\n\t\t\t\tintOffset = byteOffset >>> 2;\n\t\t\t\twhile (packed.length <= intOffset)\n\t\t\t\t{\n\t\t\t\t\tpacked.push(0);\n\t\t\t\t}\n\t\t\t\tpacked[intOffset] |= codePnt << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n\t\t\t\tbyteCnt += 2;\n\t\t\t}\n\t\t}\n\t\treturn {\"value\" : packed, \"binLen\" : byteCnt * 8 + existingPackedLen};\n\t}\n\n\t/**\n\t * Convert a hex string to an array of big-endian words\n\t *\n\t * @private\n\t * @param {string} str String to be converted to binary representation\n\t * @param {Array<number>} existingPacked A packed int array of bytes to\n\t *   append the results to\n\t * @param {number} existingPackedLen The number of bits in the existingPacked\n\t *   array\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t *   length of \"value\"\n\t */\n\tfunction hex2packed(str, existingPacked, existingPackedLen, bigEndianMod)\n\t{\n\t\tvar packed, length = str.length, i, num, intOffset, byteOffset,\n\t\t\texistingByteLen, shiftModifier;\n\n\t\tif (0 !== (length % 2))\n\t\t{\n\t\t\tthrow new Error(\"String of HEX type must be in byte increments\");\n\t\t}\n\n\t\tpacked = existingPacked || [0];\n\t\texistingPackedLen = existingPackedLen || 0;\n\t\texistingByteLen = existingPackedLen >>> 3;\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n\t\tfor (i = 0; i < length; i += 2)\n\t\t{\n\t\t\tnum = parseInt(str.substr(i, 2), 16);\n\t\t\tif (!isNaN(num))\n\t\t\t{\n\t\t\t\tbyteOffset = (i >>> 1) + existingByteLen;\n\t\t\t\tintOffset = byteOffset >>> 2;\n\t\t\t\twhile (packed.length <= intOffset)\n\t\t\t\t{\n\t\t\t\t\tpacked.push(0);\n\t\t\t\t}\n\t\t\t\tpacked[intOffset] |= num  << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new Error(\"String of HEX type contains invalid characters\");\n\t\t\t}\n\t\t}\n\n\t\treturn {\"value\" : packed, \"binLen\" : length * 4 + existingPackedLen};\n\t}\n\n\t/**\n\t * Convert a string of raw bytes to an array of big-endian words\n\t *\n\t * @private\n\t * @param {string} str String of raw bytes to be converted to binary representation\n\t * @param {Array<number>} existingPacked A packed int array of bytes to\n\t *   append the results to\n\t * @param {number} existingPackedLen The number of bits in the existingPacked\n\t *   array\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t *   length of \"value\"\n\t */\n\tfunction bytes2packed(str, existingPacked, existingPackedLen, bigEndianMod)\n\t{\n\t\tvar packed, codePnt, i, existingByteLen, intOffset,\n\t\t\tbyteOffset, shiftModifier;\n\n\t\tpacked = existingPacked || [0];\n\t\texistingPackedLen = existingPackedLen || 0;\n\t\texistingByteLen = existingPackedLen >>> 3;\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n\t\tfor (i = 0; i < str.length; i += 1)\n\t\t{\n\t\t\tcodePnt = str.charCodeAt(i);\n\n\t\t\tbyteOffset = i + existingByteLen;\n\t\t\tintOffset = byteOffset >>> 2;\n\t\t\tif (packed.length <= intOffset)\n\t\t\t{\n\t\t\t\tpacked.push(0);\n\t\t\t}\n\t\t\tpacked[intOffset] |= codePnt << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n\t\t}\n\n\t\treturn {\"value\" : packed, \"binLen\" : str.length * 8 + existingPackedLen};\n\t}\n\n\t/**\n\t * Convert a base-64 string to an array of big-endian words\n\t *\n\t * @private\n\t * @param {string} str String to be converted to binary representation\n\t * @param {Array<number>} existingPacked A packed int array of bytes to\n\t *   append the results to\n\t * @param {number} existingPackedLen The number of bits in the existingPacked\n\t *   array\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t *   length of \"value\"\n\t */\n\tfunction b642packed(str, existingPacked, existingPackedLen, bigEndianMod)\n\t{\n\t\tvar packed, byteCnt = 0, index, i, j, tmpInt, strPart, firstEqual,\n\t\t\tb64Tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n\t\t\texistingByteLen, intOffset, byteOffset, shiftModifier;\n\n\t\tif (-1 === str.search(/^[a-zA-Z0-9=+\\/]+$/))\n\t\t{\n\t\t\tthrow new Error(\"Invalid character in base-64 string\");\n\t\t}\n\n\t\tfirstEqual = str.indexOf(\"=\");\n\t\tstr = str.replace(/\\=/g, \"\");\n\t\tif ((-1 !== firstEqual) && (firstEqual < str.length))\n\t\t{\n\t\t\tthrow new Error(\"Invalid '=' found in base-64 string\");\n\t\t}\n\n\t\tpacked = existingPacked || [0];\n\t\texistingPackedLen = existingPackedLen || 0;\n\t\texistingByteLen = existingPackedLen >>> 3;\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n\t\tfor (i = 0; i < str.length; i += 4)\n\t\t{\n\t\t\tstrPart = str.substr(i, 4);\n\t\t\ttmpInt = 0;\n\n\t\t\tfor (j = 0; j < strPart.length; j += 1)\n\t\t\t{\n\t\t\t\tindex = b64Tab.indexOf(strPart[j]);\n\t\t\t\ttmpInt |= index << (18 - (6 * j));\n\t\t\t}\n\n\t\t\tfor (j = 0; j < strPart.length - 1; j += 1)\n\t\t\t{\n\t\t\t\tbyteOffset = byteCnt + existingByteLen;\n\t\t\t\tintOffset = byteOffset >>> 2;\n\t\t\t\twhile (packed.length <= intOffset)\n\t\t\t\t{\n\t\t\t\t\tpacked.push(0);\n\t\t\t\t}\n\t\t\t\tpacked[intOffset] |= ((tmpInt >>> (16 - (j * 8))) & 0xFF) <<\n\t\t\t\t\t(8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n\t\t\t\tbyteCnt += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn {\"value\" : packed, \"binLen\" : byteCnt * 8 + existingPackedLen};\n\t}\n\n\t/**\n\t * Convert an ArrayBuffer to an array of big-endian words\n\t *\n\t * @private\n\t * @param {ArrayBuffer} arr ArrayBuffer to be converted to binary\n\t *   representation\n\t * @param {Array<number>} existingPacked A packed int array of bytes to\n\t *   append the results to\n\t * @param {number} existingPackedLen The number of bits in the existingPacked\n\t *   array\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t *   length of \"value\"\n\t */\n\tfunction arraybuffer2packed(arr, existingPacked, existingPackedLen, bigEndianMod)\n\t{\n\t\tvar packed, i, existingByteLen, intOffset, byteOffset, shiftModifier, arrView;\n\n\t\tpacked = existingPacked || [0];\n\t\texistingPackedLen = existingPackedLen || 0;\n\t\texistingByteLen = existingPackedLen >>> 3;\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\t\tarrView = new Uint8Array(arr);\n\n\t\tfor (i = 0; i < arr.byteLength; i += 1)\n\t\t{\n\t\t\tbyteOffset = i + existingByteLen;\n\t\t\tintOffset = byteOffset >>> 2;\n\t\t\tif (packed.length <= intOffset)\n\t\t\t{\n\t\t\t\tpacked.push(0);\n\t\t\t}\n\t\t\tpacked[intOffset] |= arrView[i] << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n\t\t}\n\n\t\treturn {\"value\" : packed, \"binLen\" : arr.byteLength * 8 + existingPackedLen};\n\t}\n\n\t/**\n\t * Convert an array of big-endian words to a hex string.\n\t *\n\t * @private\n\t * @param {Array<number>} packed Array of integers to be converted to\n\t *   hexidecimal representation\n\t * @param {number} outputLength Length of output in bits\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @param {{outputUpper : boolean, b64Pad : string}} formatOpts Hash list\n\t *   containing validated output formatting options\n\t * @return {string} Hexidecimal representation of the parameter in string\n\t *   form\n\t */\n\tfunction packed2hex(packed, outputLength, bigEndianMod, formatOpts)\n\t{\n\t\tvar hex_tab = \"0123456789abcdef\", str = \"\",\n\t\t\tlength = outputLength / 8, i, srcByte, shiftModifier;\n\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n\t\tfor (i = 0; i < length; i += 1)\n\t\t{\n\t\t\t/* The below is more than a byte but it gets taken care of later */\n\t\t\tsrcByte = packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)));\n\t\t\tstr += hex_tab.charAt((srcByte >>> 4) & 0xF) +\n\t\t\t\thex_tab.charAt(srcByte & 0xF);\n\t\t}\n\n\t\treturn (formatOpts[\"outputUpper\"]) ? str.toUpperCase() : str;\n\t}\n\n\t/**\n\t * Convert an array of big-endian words to a base-64 string\n\t *\n\t * @private\n\t * @param {Array<number>} packed Array of integers to be converted to\n\t *   base-64 representation\n\t * @param {number} outputLength Length of output in bits\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @param {{outputUpper : boolean, b64Pad : string}} formatOpts Hash list\n\t *   containing validated output formatting options\n\t * @return {string} Base-64 encoded representation of the parameter in\n\t *   string form\n\t */\n\tfunction packed2b64(packed, outputLength, bigEndianMod, formatOpts)\n\t{\n\t\tvar str = \"\", length = outputLength / 8, i, j, triplet, int1, int2, shiftModifier,\n\t\t\tb64Tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n\t\tfor (i = 0; i < length; i += 3)\n\t\t{\n\t\t\tint1 = ((i + 1) < length) ? packed[(i + 1) >>> 2] : 0;\n\t\t\tint2 = ((i + 2) < length) ? packed[(i + 2) >>> 2] : 0;\n\t\t\ttriplet = (((packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)))) & 0xFF) << 16) |\n\t\t\t\t(((int1 >>> (8 * (shiftModifier + bigEndianMod * ((i + 1) % 4)))) & 0xFF) << 8) |\n\t\t\t\t((int2 >>> (8 * (shiftModifier + bigEndianMod * ((i + 2) % 4)))) & 0xFF);\n\t\t\tfor (j = 0; j < 4; j += 1)\n\t\t\t{\n\t\t\t\tif (i * 8 + j * 6 <= outputLength)\n\t\t\t\t{\n\t\t\t\t\tstr += b64Tab.charAt((triplet >>> 6 * (3 - j)) & 0x3F);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstr += formatOpts[\"b64Pad\"];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn str;\n\t}\n\n\t/**\n\t * Convert an array of big-endian words to raw bytes string\n\t *\n\t * @private\n\t * @param {Array<number>} packed Array of integers to be converted to\n\t *   a raw bytes string representation\n\t * @param {number} outputLength Length of output in bits\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {string} Raw bytes representation of the parameter in string\n\t *   form\n\t */\n\tfunction packed2bytes(packed, outputLength, bigEndianMod)\n\t{\n\t\tvar str = \"\", length = outputLength / 8, i, srcByte, shiftModifier;\n\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n\t\tfor (i = 0; i < length; i += 1)\n\t\t{\n\t\t\tsrcByte = (packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)))) & 0xFF;\n\t\t\tstr += String.fromCharCode(srcByte);\n\t\t}\n\n\t\treturn str;\n\t}\n\n\t/**\n\t * Convert an array of big-endian words to an ArrayBuffer\n\t *\n\t * @private\n\t * @param {Array<number>} packed Array of integers to be converted to\n\t *   an ArrayBuffer\n\t * @param {number} outputLength Length of output in bits\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {ArrayBuffer} Raw bytes representation of the parameter in an\n\t *   ArrayBuffer\n\t */\n\tfunction packed2arraybuffer(packed, outputLength, bigEndianMod)\n\t{\n\t\tvar length = outputLength / 8, i, retVal = new ArrayBuffer(length), shiftModifier, arrView;\n\t\tarrView = new Uint8Array(retVal);\n\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n\t\tfor (i = 0; i < length; i += 1)\n\t\t{\n\t\t\tarrView[i] = (packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)))) & 0xFF;\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * Validate hash list containing output formatting options, ensuring\n\t * presence of every option or adding the default value\n\t *\n\t * @private\n\t * @param {{outputUpper : (boolean|undefined), b64Pad : (string|undefined),\n\t *   shakeLen : (number|undefined)}=} options Hash list of output formatting options\n\t * @return {{outputUpper : boolean, b64Pad : string, shakeLen : number}} Validated\n\t *   hash list containing output formatting options\n\t */\n\tfunction getOutputOpts(options)\n\t{\n\t\tvar retVal = {\"outputUpper\" : false, \"b64Pad\" : \"=\", \"shakeLen\" : -1},\n\t\t\toutputOptions;\n\t\toutputOptions = options || {};\n\n\t\tretVal[\"outputUpper\"] = outputOptions[\"outputUpper\"] || false;\n\n\t\tif (true === outputOptions.hasOwnProperty(\"b64Pad\"))\n\t\t{\n\t\t\tretVal[\"b64Pad\"] = outputOptions[\"b64Pad\"];\n\t\t}\n\n\t\tif ((true === outputOptions.hasOwnProperty(\"shakeLen\")) && ((8 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tif (outputOptions[\"shakeLen\"] % 8 !== 0)\n\t\t\t{\n\t\t\t\tthrow new Error(\"shakeLen must be a multiple of 8\");\n\t\t\t}\n\t\t\tretVal[\"shakeLen\"] = outputOptions[\"shakeLen\"];\n\t\t}\n\n\t\tif (\"boolean\" !== typeof(retVal[\"outputUpper\"]))\n\t\t{\n\t\t\tthrow new Error(\"Invalid outputUpper formatting option\");\n\t\t}\n\n\t\tif (\"string\" !== typeof(retVal[\"b64Pad\"]))\n\t\t{\n\t\t\tthrow new Error(\"Invalid b64Pad formatting option\");\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * Function that takes an input format and UTF encoding and returns the\n\t * appropriate function used to convert the input.\n\t *\n\t * @private\n\t * @param {string} format The format of the string to be converted\n\t * @param {string} utfType The string encoding to use (UTF8, UTF16BE,\n\t *\tUTF16LE)\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {function((string|ArrayBuffer), Array<number>=, number=): {value :\n\t *   Array<number>, binLen : number}} Function that will convert an input\n\t *   string to a packed int array\n\t */\n\tfunction getStrConverter(format, utfType, bigEndianMod)\n\t{\n\t\tvar retVal;\n\n\t\t/* Validate encoding */\n\t\tswitch (utfType)\n\t\t{\n\t\tcase \"UTF8\":\n\t\t\t/* Fallthrough */\n\t\tcase \"UTF16BE\":\n\t\t\t/* Fallthrough */\n\t\tcase \"UTF16LE\":\n\t\t\t/* Fallthrough */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error(\"encoding must be UTF8, UTF16BE, or UTF16LE\");\n\t\t}\n\n\t\t/* Map inputFormat to the appropriate converter */\n\t\tswitch (format)\n\t\t{\n\t\tcase \"HEX\":\n\t\t\t/**\n\t\t\t * @param {string} str String of raw bytes to be converted to binary representation\n\t\t\t * @param {Array<number>} existingBin A packed int array of bytes to\n\t\t\t *   append the results to\n\t\t\t * @param {number} existingBinLen The number of bits in the existingBin\n\t\t\t *   array\n\t\t\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t\t\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t\t\t *   length of \"value\"\n\t\t\t */\n\t\t\tretVal = function(str, existingBin, existingBinLen)\n\t\t\t\t{\n\t\t\t\t   return hex2packed(str, existingBin, existingBinLen, bigEndianMod);\n\t\t\t\t};\n\t\t\tbreak;\n\t\tcase \"TEXT\":\n\t\t\t/**\n\t\t\t * @param {string} str String of raw bytes to be converted to binary representation\n\t\t\t * @param {Array<number>} existingBin A packed int array of bytes to\n\t\t\t *   append the results to\n\t\t\t * @param {number} existingBinLen The number of bits in the existingBin\n\t\t\t *   array\n\t\t\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t\t\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t\t\t *   length of \"value\"\n\t\t\t */\n\t\t\tretVal = function(str, existingBin, existingBinLen)\n\t\t\t\t{\n\t\t\t\t\treturn str2packed(str, utfType, existingBin, existingBinLen, bigEndianMod);\n\t\t\t\t};\n\t\t\tbreak;\n\t\tcase \"B64\":\n\t\t\t/**\n\t\t\t * @param {string} str String of raw bytes to be converted to binary representation\n\t\t\t * @param {Array<number>} existingBin A packed int array of bytes to\n\t\t\t *   append the results to\n\t\t\t * @param {number} existingBinLen The number of bits in the existingBin\n\t\t\t *   array\n\t\t\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t\t\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t\t\t *   length of \"value\"\n\t\t\t */\n\t\t\tretVal = function(str, existingBin, existingBinLen)\n\t\t\t\t{\n\t\t\t\t   return b642packed(str, existingBin, existingBinLen, bigEndianMod);\n\t\t\t\t};\n\t\t\tbreak;\n\t\tcase \"BYTES\":\n\t\t\t/**\n\t\t\t * @param {string} str String of raw bytes to be converted to binary representation\n\t\t\t * @param {Array<number>} existingBin A packed int array of bytes to\n\t\t\t *   append the results to\n\t\t\t * @param {number} existingBinLen The number of bits in the existingBin\n\t\t\t *   array\n\t\t\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t\t\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t\t\t *   length of \"value\"\n\t\t\t */\n\t\t\tretVal = function(str, existingBin, existingBinLen)\n\t\t\t\t{\n\t\t\t\t   return bytes2packed(str, existingBin, existingBinLen, bigEndianMod);\n\t\t\t\t};\n\t\t\tbreak;\n\t\tcase \"ARRAYBUFFER\":\n\t\t\ttry {\n\t\t\t\tretVal = new ArrayBuffer(0);\n\t\t\t} catch(ignore) {\n\t\t\t\tthrow new Error(\"ARRAYBUFFER not supported by this environment\");\n\t\t\t}\n\t\t\t/**\n\t\t\t * @param {ArrayBuffer} arr ArrayBuffer to be converted to binary\n\t\t\t *   representation\n\t\t\t * @param {Array<number>} existingBin A packed int array of bytes to\n\t\t\t *   append the results to\n\t\t\t * @param {number} existingBinLen The number of bits in the existingBin\n\t\t\t *   array\n\t\t\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t\t\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t\t\t *   length of \"value\"\n\t\t\t */\n\t\t\tretVal = function(arr, existingBin, existingBinLen)\n\t\t\t\t{\n\t\t\t\t   return arraybuffer2packed(arr, existingBin, existingBinLen, bigEndianMod);\n\t\t\t\t};\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error(\"format must be HEX, TEXT, B64, BYTES, or ARRAYBUFFER\");\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * The 32-bit implementation of circular rotate left\n\t *\n\t * @private\n\t * @param {number} x The 32-bit integer argument\n\t * @param {number} n The number of bits to shift\n\t * @return {number} The x shifted circularly by n bits\n\t */\n\tfunction rotl_32(x, n)\n\t{\n\t\treturn (x << n) | (x >>> (32 - n));\n\t}\n\n\t/**\n\t * The 64-bit implementation of circular rotate left\n\t *\n\t * @private\n\t * @param {Int_64} x The 64-bit integer argument\n\t * @param {number} n The number of bits to shift\n\t * @return {Int_64} The x shifted circularly by n bits\n\t */\n\tfunction rotl_64(x, n)\n\t{\n\t\tif (n > 32)\n\t\t{\n\t\t\tn = n - 32;\n\t\t\treturn new Int_64(\n\t\t\t\tx.lowOrder << n | x.highOrder >>> (32 - n),\n\t\t\t\tx.highOrder << n | x.lowOrder >>> (32 - n)\n\t\t\t);\n\t\t}\n\t\telse if (0 !== n)\n\t\t{\n\t\t\treturn new Int_64(\n\t\t\t\tx.highOrder << n | x.lowOrder >>> (32 - n),\n\t\t\t\tx.lowOrder << n | x.highOrder >>> (32 - n)\n\t\t\t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t}\n\n\t/**\n\t * The 32-bit implementation of circular rotate right\n\t *\n\t * @private\n\t * @param {number} x The 32-bit integer argument\n\t * @param {number} n The number of bits to shift\n\t * @return {number} The x shifted circularly by n bits\n\t */\n\tfunction rotr_32(x, n)\n\t{\n\t\treturn (x >>> n) | (x << (32 - n));\n\t}\n\n\t/**\n\t * The 64-bit implementation of circular rotate right\n\t *\n\t * @private\n\t * @param {Int_64} x The 64-bit integer argument\n\t * @param {number} n The number of bits to shift\n\t * @return {Int_64} The x shifted circularly by n bits\n\t */\n\tfunction rotr_64(x, n)\n\t{\n\t\tvar retVal = null, tmp = new Int_64(x.highOrder, x.lowOrder);\n\n\t\tif (32 >= n)\n\t\t{\n\t\t\tretVal = new Int_64(\n\t\t\t\t\t(tmp.highOrder >>> n) | ((tmp.lowOrder << (32 - n)) & 0xFFFFFFFF),\n\t\t\t\t\t(tmp.lowOrder >>> n) | ((tmp.highOrder << (32 - n)) & 0xFFFFFFFF)\n\t\t\t\t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tretVal = new Int_64(\n\t\t\t\t\t(tmp.lowOrder >>> (n - 32)) | ((tmp.highOrder << (64 - n)) & 0xFFFFFFFF),\n\t\t\t\t\t(tmp.highOrder >>> (n - 32)) | ((tmp.lowOrder << (64 - n)) & 0xFFFFFFFF)\n\t\t\t\t);\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * The 32-bit implementation of shift right\n\t *\n\t * @private\n\t * @param {number} x The 32-bit integer argument\n\t * @param {number} n The number of bits to shift\n\t * @return {number} The x shifted by n bits\n\t */\n\tfunction shr_32(x, n)\n\t{\n\t\treturn x >>> n;\n\t}\n\n\t/**\n\t * The 64-bit implementation of shift right\n\t *\n\t * @private\n\t * @param {Int_64} x The 64-bit integer argument\n\t * @param {number} n The number of bits to shift\n\t * @return {Int_64} The x shifted by n bits\n\t */\n\tfunction shr_64(x, n)\n\t{\n\t\tvar retVal = null;\n\n\t\tif (32 >= n)\n\t\t{\n\t\t\tretVal = new Int_64(\n\t\t\t\t\tx.highOrder >>> n,\n\t\t\t\t\tx.lowOrder >>> n | ((x.highOrder << (32 - n)) & 0xFFFFFFFF)\n\t\t\t\t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tretVal = new Int_64(\n\t\t\t\t\t0,\n\t\t\t\t\tx.highOrder >>> (n - 32)\n\t\t\t\t);\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * The 32-bit implementation of the NIST specified Parity function\n\t *\n\t * @private\n\t * @param {number} x The first 32-bit integer argument\n\t * @param {number} y The second 32-bit integer argument\n\t * @param {number} z The third 32-bit integer argument\n\t * @return {number} The NIST specified output of the function\n\t */\n\tfunction parity_32(x, y, z)\n\t{\n\t\treturn x ^ y ^ z;\n\t}\n\n\t/**\n\t * The 32-bit implementation of the NIST specified Ch function\n\t *\n\t * @private\n\t * @param {number} x The first 32-bit integer argument\n\t * @param {number} y The second 32-bit integer argument\n\t * @param {number} z The third 32-bit integer argument\n\t * @return {number} The NIST specified output of the function\n\t */\n\tfunction ch_32(x, y, z)\n\t{\n\t\treturn (x & y) ^ (~x & z);\n\t}\n\n\t/**\n\t * The 64-bit implementation of the NIST specified Ch function\n\t *\n\t * @private\n\t * @param {Int_64} x The first 64-bit integer argument\n\t * @param {Int_64} y The second 64-bit integer argument\n\t * @param {Int_64} z The third 64-bit integer argument\n\t * @return {Int_64} The NIST specified output of the function\n\t */\n\tfunction ch_64(x, y, z)\n\t{\n\t\treturn new Int_64(\n\t\t\t\t(x.highOrder & y.highOrder) ^ (~x.highOrder & z.highOrder),\n\t\t\t\t(x.lowOrder & y.lowOrder) ^ (~x.lowOrder & z.lowOrder)\n\t\t\t);\n\t}\n\n\t/**\n\t * The 32-bit implementation of the NIST specified Maj function\n\t *\n\t * @private\n\t * @param {number} x The first 32-bit integer argument\n\t * @param {number} y The second 32-bit integer argument\n\t * @param {number} z The third 32-bit integer argument\n\t * @return {number} The NIST specified output of the function\n\t */\n\tfunction maj_32(x, y, z)\n\t{\n\t\treturn (x & y) ^ (x & z) ^ (y & z);\n\t}\n\n\t/**\n\t * The 64-bit implementation of the NIST specified Maj function\n\t *\n\t * @private\n\t * @param {Int_64} x The first 64-bit integer argument\n\t * @param {Int_64} y The second 64-bit integer argument\n\t * @param {Int_64} z The third 64-bit integer argument\n\t * @return {Int_64} The NIST specified output of the function\n\t */\n\tfunction maj_64(x, y, z)\n\t{\n\t\treturn new Int_64(\n\t\t\t\t(x.highOrder & y.highOrder) ^\n\t\t\t\t(x.highOrder & z.highOrder) ^\n\t\t\t\t(y.highOrder & z.highOrder),\n\t\t\t\t(x.lowOrder & y.lowOrder) ^\n\t\t\t\t(x.lowOrder & z.lowOrder) ^\n\t\t\t\t(y.lowOrder & z.lowOrder)\n\t\t\t);\n\t}\n\n\t/**\n\t * The 32-bit implementation of the NIST specified Sigma0 function\n\t *\n\t * @private\n\t * @param {number} x The 32-bit integer argument\n\t * @return {number} The NIST specified output of the function\n\t */\n\tfunction sigma0_32(x)\n\t{\n\t\treturn rotr_32(x, 2) ^ rotr_32(x, 13) ^ rotr_32(x, 22);\n\t}\n\n\t/**\n\t * The 64-bit implementation of the NIST specified Sigma0 function\n\t *\n\t * @private\n\t * @param {Int_64} x The 64-bit integer argument\n\t * @return {Int_64} The NIST specified output of the function\n\t */\n\tfunction sigma0_64(x)\n\t{\n\t\tvar rotr28 = rotr_64(x, 28), rotr34 = rotr_64(x, 34),\n\t\t\trotr39 = rotr_64(x, 39);\n\n\t\treturn new Int_64(\n\t\t\t\trotr28.highOrder ^ rotr34.highOrder ^ rotr39.highOrder,\n\t\t\t\trotr28.lowOrder ^ rotr34.lowOrder ^ rotr39.lowOrder);\n\t}\n\n\t/**\n\t * The 32-bit implementation of the NIST specified Sigma1 function\n\t *\n\t * @private\n\t * @param {number} x The 32-bit integer argument\n\t * @return {number} The NIST specified output of the function\n\t */\n\tfunction sigma1_32(x)\n\t{\n\t\treturn rotr_32(x, 6) ^ rotr_32(x, 11) ^ rotr_32(x, 25);\n\t}\n\n\t/**\n\t * The 64-bit implementation of the NIST specified Sigma1 function\n\t *\n\t * @private\n\t * @param {Int_64} x The 64-bit integer argument\n\t * @return {Int_64} The NIST specified output of the function\n\t */\n\tfunction sigma1_64(x)\n\t{\n\t\tvar rotr14 = rotr_64(x, 14), rotr18 = rotr_64(x, 18),\n\t\t\trotr41 = rotr_64(x, 41);\n\n\t\treturn new Int_64(\n\t\t\t\trotr14.highOrder ^ rotr18.highOrder ^ rotr41.highOrder,\n\t\t\t\trotr14.lowOrder ^ rotr18.lowOrder ^ rotr41.lowOrder);\n\t}\n\n\t/**\n\t * The 32-bit implementation of the NIST specified Gamma0 function\n\t *\n\t * @private\n\t * @param {number} x The 32-bit integer argument\n\t * @return {number} The NIST specified output of the function\n\t */\n\tfunction gamma0_32(x)\n\t{\n\t\treturn rotr_32(x, 7) ^ rotr_32(x, 18) ^ shr_32(x, 3);\n\t}\n\n\t/**\n\t * The 64-bit implementation of the NIST specified Gamma0 function\n\t *\n\t * @private\n\t * @param {Int_64} x The 64-bit integer argument\n\t * @return {Int_64} The NIST specified output of the function\n\t */\n\tfunction gamma0_64(x)\n\t{\n\t\tvar rotr1 = rotr_64(x, 1), rotr8 = rotr_64(x, 8), shr7 = shr_64(x, 7);\n\n\t\treturn new Int_64(\n\t\t\t\trotr1.highOrder ^ rotr8.highOrder ^ shr7.highOrder,\n\t\t\t\trotr1.lowOrder ^ rotr8.lowOrder ^ shr7.lowOrder\n\t\t\t);\n\t}\n\n\t/**\n\t * The 32-bit implementation of the NIST specified Gamma1 function\n\t *\n\t * @private\n\t * @param {number} x The 32-bit integer argument\n\t * @return {number} The NIST specified output of the function\n\t */\n\tfunction gamma1_32(x)\n\t{\n\t\treturn rotr_32(x, 17) ^ rotr_32(x, 19) ^ shr_32(x, 10);\n\t}\n\n\t/**\n\t * The 64-bit implementation of the NIST specified Gamma1 function\n\t *\n\t * @private\n\t * @param {Int_64} x The 64-bit integer argument\n\t * @return {Int_64} The NIST specified output of the function\n\t */\n\tfunction gamma1_64(x)\n\t{\n\t\tvar rotr19 = rotr_64(x, 19), rotr61 = rotr_64(x, 61),\n\t\t\tshr6 = shr_64(x, 6);\n\n\t\treturn new Int_64(\n\t\t\t\trotr19.highOrder ^ rotr61.highOrder ^ shr6.highOrder,\n\t\t\t\trotr19.lowOrder ^ rotr61.lowOrder ^ shr6.lowOrder\n\t\t\t);\n\t}\n\n\t/**\n\t * Add two 32-bit integers, wrapping at 2^32. This uses 16-bit operations\n\t * internally to work around bugs in some JS interpreters.\n\t *\n\t * @private\n\t * @param {number} a The first 32-bit integer argument to be added\n\t * @param {number} b The second 32-bit integer argument to be added\n\t * @return {number} The sum of a + b\n\t */\n\tfunction safeAdd_32_2(a, b)\n\t{\n\t\tvar lsw = (a & 0xFFFF) + (b & 0xFFFF),\n\t\t\tmsw = (a >>> 16) + (b >>> 16) + (lsw >>> 16);\n\n\t\treturn ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\t}\n\n\t/**\n\t * Add four 32-bit integers, wrapping at 2^32. This uses 16-bit operations\n\t * internally to work around bugs in some JS interpreters.\n\t *\n\t * @private\n\t * @param {number} a The first 32-bit integer argument to be added\n\t * @param {number} b The second 32-bit integer argument to be added\n\t * @param {number} c The third 32-bit integer argument to be added\n\t * @param {number} d The fourth 32-bit integer argument to be added\n\t * @return {number} The sum of a + b + c + d\n\t */\n\tfunction safeAdd_32_4(a, b, c, d)\n\t{\n\t\tvar lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF),\n\t\t\tmsw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) +\n\t\t\t\t(lsw >>> 16);\n\n\t\treturn ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\t}\n\n\t/**\n\t * Add five 32-bit integers, wrapping at 2^32. This uses 16-bit operations\n\t * internally to work around bugs in some JS interpreters.\n\t *\n\t * @private\n\t * @param {number} a The first 32-bit integer argument to be added\n\t * @param {number} b The second 32-bit integer argument to be added\n\t * @param {number} c The third 32-bit integer argument to be added\n\t * @param {number} d The fourth 32-bit integer argument to be added\n\t * @param {number} e The fifth 32-bit integer argument to be added\n\t * @return {number} The sum of a + b + c + d + e\n\t */\n\tfunction safeAdd_32_5(a, b, c, d, e)\n\t{\n\t\tvar lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF) +\n\t\t\t\t(e & 0xFFFF),\n\t\t\tmsw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) +\n\t\t\t\t(e >>> 16) + (lsw >>> 16);\n\n\t\treturn ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\t}\n\n\t/**\n\t * Add two 64-bit integers, wrapping at 2^64. This uses 16-bit operations\n\t * internally to work around bugs in some JS interpreters.\n\t *\n\t * @private\n\t * @param {Int_64} x The first 64-bit integer argument to be added\n\t * @param {Int_64} y The second 64-bit integer argument to be added\n\t * @return {Int_64} The sum of x + y\n\t */\n\tfunction safeAdd_64_2(x, y)\n\t{\n\t\tvar lsw, msw, lowOrder, highOrder;\n\n\t\tlsw = (x.lowOrder & 0xFFFF) + (y.lowOrder & 0xFFFF);\n\t\tmsw = (x.lowOrder >>> 16) + (y.lowOrder >>> 16) + (lsw >>> 16);\n\t\tlowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n\t\tlsw = (x.highOrder & 0xFFFF) + (y.highOrder & 0xFFFF) + (msw >>> 16);\n\t\tmsw = (x.highOrder >>> 16) + (y.highOrder >>> 16) + (lsw >>> 16);\n\t\thighOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n\t\treturn new Int_64(highOrder, lowOrder);\n\t}\n\n\t/**\n\t * Add four 64-bit integers, wrapping at 2^64. This uses 16-bit operations\n\t * internally to work around bugs in some JS interpreters.\n\t *\n\t * @private\n\t * @param {Int_64} a The first 64-bit integer argument to be added\n\t * @param {Int_64} b The second 64-bit integer argument to be added\n\t * @param {Int_64} c The third 64-bit integer argument to be added\n\t * @param {Int_64} d The fouth 64-bit integer argument to be added\n\t * @return {Int_64} The sum of a + b + c + d\n\t */\n\tfunction safeAdd_64_4(a, b, c, d)\n\t{\n\t\tvar lsw, msw, lowOrder, highOrder;\n\n\t\tlsw = (a.lowOrder & 0xFFFF) + (b.lowOrder & 0xFFFF) +\n\t\t\t(c.lowOrder & 0xFFFF) + (d.lowOrder & 0xFFFF);\n\t\tmsw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) +\n\t\t\t(c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (lsw >>> 16);\n\t\tlowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n\t\tlsw = (a.highOrder & 0xFFFF) + (b.highOrder & 0xFFFF) +\n\t\t\t(c.highOrder & 0xFFFF) + (d.highOrder & 0xFFFF) + (msw >>> 16);\n\t\tmsw = (a.highOrder >>> 16) + (b.highOrder >>> 16) +\n\t\t\t(c.highOrder >>> 16) + (d.highOrder >>> 16) + (lsw >>> 16);\n\t\thighOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n\t\treturn new Int_64(highOrder, lowOrder);\n\t}\n\n\t/**\n\t * Add five 64-bit integers, wrapping at 2^64. This uses 16-bit operations\n\t * internally to work around bugs in some JS interpreters.\n\t *\n\t * @private\n\t * @param {Int_64} a The first 64-bit integer argument to be added\n\t * @param {Int_64} b The second 64-bit integer argument to be added\n\t * @param {Int_64} c The third 64-bit integer argument to be added\n\t * @param {Int_64} d The fouth 64-bit integer argument to be added\n\t * @param {Int_64} e The fouth 64-bit integer argument to be added\n\t * @return {Int_64} The sum of a + b + c + d + e\n\t */\n\tfunction safeAdd_64_5(a, b, c, d, e)\n\t{\n\t\tvar lsw, msw, lowOrder, highOrder;\n\n\t\tlsw = (a.lowOrder & 0xFFFF) + (b.lowOrder & 0xFFFF) +\n\t\t\t(c.lowOrder & 0xFFFF) + (d.lowOrder & 0xFFFF) +\n\t\t\t(e.lowOrder & 0xFFFF);\n\t\tmsw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) +\n\t\t\t(c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (e.lowOrder >>> 16) +\n\t\t\t(lsw >>> 16);\n\t\tlowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n\t\tlsw = (a.highOrder & 0xFFFF) + (b.highOrder & 0xFFFF) +\n\t\t\t(c.highOrder & 0xFFFF) + (d.highOrder & 0xFFFF) +\n\t\t\t(e.highOrder & 0xFFFF) + (msw >>> 16);\n\t\tmsw = (a.highOrder >>> 16) + (b.highOrder >>> 16) +\n\t\t\t(c.highOrder >>> 16) + (d.highOrder >>> 16) +\n\t\t\t(e.highOrder >>> 16) + (lsw >>> 16);\n\t\thighOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n\t\treturn new Int_64(highOrder, lowOrder);\n\t}\n\n\t/**\n\t * XORs two given arguments.\n\t *\n\t * @private\n\t * @param {Int_64} a First argument to be XORed\n\t * @param {Int_64} b Second argument to be XORed\n\t * @return {Int_64} The XOR of the arguments\n\t */\n\tfunction xor_64_2(a, b)\n\t{\n\t\treturn new Int_64(\n\t\t\ta.highOrder ^ b.highOrder,\n\t\t\ta.lowOrder ^ b.lowOrder\n\t\t);\n\t}\n\n\t/**\n\t * XORs five given arguments.\n\t *\n\t * @private\n\t * @param {Int_64} a First argument to be XORed\n\t * @param {Int_64} b Second argument to be XORed\n\t * @param {Int_64} c Third argument to be XORed\n\t * @param {Int_64} d Fourth argument to be XORed\n\t * @param {Int_64} e Fifth argument to be XORed\n\t * @return {Int_64} The XOR of the arguments\n\t */\n\tfunction xor_64_5(a, b, c, d, e)\n\t{\n\t\treturn new Int_64(\n\t\t\ta.highOrder ^ b.highOrder ^ c.highOrder ^ d.highOrder ^ e.highOrder,\n\t\t\ta.lowOrder ^ b.lowOrder ^ c.lowOrder ^ d.lowOrder ^ e.lowOrder\n\t\t);\n\t}\n\n\t/**\n\t * Returns a clone of the given SHA3 state\n\t *\n\t * @private\n\t * @param {Array<Array<Int_64>>} state The state to be cloned\n\t * @return {Array<Array<Int_64>>} The cloned state\n\t */\n\tfunction cloneSHA3State(state) {\n\t\tvar clone = [], i;\n\t\tfor (i = 0; i < 5; i += 1)\n\t\t{\n\t\t\tclone[i] = state[i].slice();\n\t\t}\n\n\t\treturn clone;\n\t}\n\n\t/**\n\t * Gets the state values for the specified SHA variant\n\t *\n\t * @param {string} variant The SHA variant\n\t * @return {Array<number|Int_64|Array<null>>} The initial state values\n\t */\n\tfunction getNewState(variant)\n\t{\n\t\tvar retVal = [], H_trunc, H_full, i;\n\n\t\tif ((\"SHA-1\" === variant) && ((1 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tretVal = [\n\t\t\t\t0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0\n\t\t\t];\n\t\t}\n\t\telse if ((variant.lastIndexOf(\"SHA-\", 0) === 0) && ((6 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tH_trunc = [\n\t\t\t\t0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n\t\t\t\t0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n\t\t\t];\n\t\t\tH_full = [\n\t\t\t\t0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,\n\t\t\t\t0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\n\t\t\t];\n\n\t\t\tswitch (variant)\n\t\t\t{\n\t\t\tcase \"SHA-224\":\n\t\t\t\tretVal = H_trunc;\n\t\t\t\tbreak;\n\t\t\tcase \"SHA-256\":\n\t\t\t\tretVal = H_full;\n\t\t\t\tbreak;\n\t\t\tcase \"SHA-384\":\n\t\t\t\tretVal = [\n\t\t\t\t\tnew Int_64(0xcbbb9d5d, H_trunc[0]),\n\t\t\t\t\tnew Int_64(0x0629a292a, H_trunc[1]),\n\t\t\t\t\tnew Int_64(0x9159015a, H_trunc[2]),\n\t\t\t\t\tnew Int_64(0x0152fecd8, H_trunc[3]),\n\t\t\t\t\tnew Int_64(0x67332667, H_trunc[4]),\n\t\t\t\t\tnew Int_64(0x98eb44a87, H_trunc[5]),\n\t\t\t\t\tnew Int_64(0xdb0c2e0d, H_trunc[6]),\n\t\t\t\t\tnew Int_64(0x047b5481d, H_trunc[7])\n\t\t\t\t];\n\t\t\t\tbreak;\n\t\t\tcase \"SHA-512\":\n\t\t\t\tretVal = [\n\t\t\t\t\tnew Int_64(H_full[0], 0xf3bcc908),\n\t\t\t\t\tnew Int_64(H_full[1], 0x84caa73b),\n\t\t\t\t\tnew Int_64(H_full[2], 0xfe94f82b),\n\t\t\t\t\tnew Int_64(H_full[3], 0x5f1d36f1),\n\t\t\t\t\tnew Int_64(H_full[4], 0xade682d1),\n\t\t\t\t\tnew Int_64(H_full[5], 0x2b3e6c1f),\n\t\t\t\t\tnew Int_64(H_full[6], 0xfb41bd6b),\n\t\t\t\t\tnew Int_64(H_full[7], 0x137e2179)\n\t\t\t\t];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unknown SHA variant\");\n\t\t\t}\n\t\t}\n\t\telse if (((variant.lastIndexOf(\"SHA3-\", 0) === 0) || (variant.lastIndexOf(\"SHAKE\", 0) === 0)) &&\n\t\t\t((8 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tfor (i = 0; i < 5; i += 1)\n\t\t\t{\n\t\t\t\tretVal[i] = [new Int_64(0, 0), new Int_64(0, 0), new Int_64(0, 0), new Int_64(0, 0), new Int_64(0, 0)];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new Error(\"No SHA variants supported\");\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * Performs a round of SHA-1 hashing over a 512-byte block\n\t *\n\t * @private\n\t * @param {Array<number>} block The binary array representation of the\n\t *   block to hash\n\t * @param {Array<number>} H The intermediate H values from a previous\n\t *   round\n\t * @return {Array<number>} The resulting H values\n\t */\n\tfunction roundSHA1(block, H)\n\t{\n\t\tvar W = [], a, b, c, d, e, T, ch = ch_32, parity = parity_32,\n\t\t\tmaj = maj_32, rotl = rotl_32, safeAdd_2 = safeAdd_32_2, t,\n\t\t\tsafeAdd_5 = safeAdd_32_5;\n\n\t\ta = H[0];\n\t\tb = H[1];\n\t\tc = H[2];\n\t\td = H[3];\n\t\te = H[4];\n\n\t\tfor (t = 0; t < 80; t += 1)\n\t\t{\n\t\t\tif (t < 16)\n\t\t\t{\n\t\t\t\tW[t] = block[t];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tW[t] = rotl(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n\t\t\t}\n\n\t\t\tif (t < 20)\n\t\t\t{\n\t\t\t\tT = safeAdd_5(rotl(a, 5), ch(b, c, d), e, 0x5a827999, W[t]);\n\t\t\t}\n\t\t\telse if (t < 40)\n\t\t\t{\n\t\t\t\tT = safeAdd_5(rotl(a, 5), parity(b, c, d), e, 0x6ed9eba1, W[t]);\n\t\t\t}\n\t\t\telse if (t < 60)\n\t\t\t{\n\t\t\t\tT = safeAdd_5(rotl(a, 5), maj(b, c, d), e, 0x8f1bbcdc, W[t]);\n\t\t\t} else {\n\t\t\t\tT = safeAdd_5(rotl(a, 5), parity(b, c, d), e, 0xca62c1d6, W[t]);\n\t\t\t}\n\n\t\t\te = d;\n\t\t\td = c;\n\t\t\tc = rotl(b, 30);\n\t\t\tb = a;\n\t\t\ta = T;\n\t\t}\n\n\t\tH[0] = safeAdd_2(a, H[0]);\n\t\tH[1] = safeAdd_2(b, H[1]);\n\t\tH[2] = safeAdd_2(c, H[2]);\n\t\tH[3] = safeAdd_2(d, H[3]);\n\t\tH[4] = safeAdd_2(e, H[4]);\n\n\t\treturn H;\n\t}\n\n\t/**\n\t * Finalizes the SHA-1 hash\n\t *\n\t * @private\n\t * @param {Array<number>} remainder Any leftover unprocessed packed ints\n\t *   that still need to be processed\n\t * @param {number} remainderBinLen The number of bits in remainder\n\t * @param {number} processedBinLen The number of bits already\n\t *   processed\n\t * @param {Array<number>} H The intermediate H values from a previous\n\t *   round\n\t * @param {number} outputLen Unused for this variant\n\t * @return {Array<number>} The array of integers representing the SHA-1\n\t *   hash of message\n\t */\n\tfunction finalizeSHA1(remainder, remainderBinLen, processedBinLen, H, outputLen)\n\t{\n\t\tvar i, appendedMessageLength, offset, totalLen;\n\n\t\t/* The 65 addition is a hack but it works.  The correct number is\n\t\t   actually 72 (64 + 8) but the below math fails if\n\t\t   remainderBinLen + 72 % 512 = 0. Since remainderBinLen % 8 = 0,\n\t\t   \"shorting\" the addition is OK. */\n\t\toffset = (((remainderBinLen + 65) >>> 9) << 4) + 15;\n\t\twhile (remainder.length <= offset)\n\t\t{\n\t\t\tremainder.push(0);\n\t\t}\n\t\t/* Append '1' at the end of the binary string */\n\t\tremainder[remainderBinLen >>> 5] |= 0x80 << (24 - (remainderBinLen % 32));\n\t\t/* Append length of binary string in the position such that the new\n\t\t * length is a multiple of 512.  Logic does not work for even multiples\n\t\t * of 512 but there can never be even multiples of 512. JavaScript\n\t\t * numbers are limited to 2^53 so it's \"safe\" to treat the totalLen as\n\t\t * a 64-bit integer. */\n\t\ttotalLen = remainderBinLen + processedBinLen;\n\t\tremainder[offset] = totalLen & 0xFFFFFFFF;\n\t\t/* Bitwise operators treat the operand as a 32-bit number so need to\n\t\t * use hacky division and round to get access to upper 32-ish bits */\n\t\tremainder[offset - 1] = (totalLen / TWO_PWR_32) | 0;\n\n\t\tappendedMessageLength = remainder.length;\n\n\t\t/* This will always be at least 1 full chunk */\n\t\tfor (i = 0; i < appendedMessageLength; i += 16)\n\t\t{\n\t\t\tH = roundSHA1(remainder.slice(i, i + 16), H);\n\t\t}\n\n\t\treturn H;\n\t}\n\n\t/* Put this here so the K arrays aren't put on the stack for every block */\n\tvar K_sha2, K_sha512, r_sha3, rc_sha3;\n\tif ((6 & SUPPORTED_ALGS) !== 0)\n\t{\n\t\tK_sha2 = [\n\t\t\t0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,\n\t\t\t0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,\n\t\t\t0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\n\t\t\t0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,\n\t\t\t0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,\n\t\t\t0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\n\t\t\t0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,\n\t\t\t0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,\n\t\t\t0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\n\t\t\t0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,\n\t\t\t0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,\n\t\t\t0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\n\t\t\t0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,\n\t\t\t0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,\n\t\t\t0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\n\t\t\t0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\n\t\t];\n\n\t\tif ((4 & SUPPORTED_ALGS) !== 0)\n\t\t{\n\t\t\t K_sha512 = [\n\t\t\t\tnew Int_64(K_sha2[ 0], 0xd728ae22), new Int_64(K_sha2[ 1], 0x23ef65cd),\n\t\t\t\tnew Int_64(K_sha2[ 2], 0xec4d3b2f), new Int_64(K_sha2[ 3], 0x8189dbbc),\n\t\t\t\tnew Int_64(K_sha2[ 4], 0xf348b538), new Int_64(K_sha2[ 5], 0xb605d019),\n\t\t\t\tnew Int_64(K_sha2[ 6], 0xaf194f9b), new Int_64(K_sha2[ 7], 0xda6d8118),\n\t\t\t\tnew Int_64(K_sha2[ 8], 0xa3030242), new Int_64(K_sha2[ 9], 0x45706fbe),\n\t\t\t\tnew Int_64(K_sha2[10], 0x4ee4b28c), new Int_64(K_sha2[11], 0xd5ffb4e2),\n\t\t\t\tnew Int_64(K_sha2[12], 0xf27b896f), new Int_64(K_sha2[13], 0x3b1696b1),\n\t\t\t\tnew Int_64(K_sha2[14], 0x25c71235), new Int_64(K_sha2[15], 0xcf692694),\n\t\t\t\tnew Int_64(K_sha2[16], 0x9ef14ad2), new Int_64(K_sha2[17], 0x384f25e3),\n\t\t\t\tnew Int_64(K_sha2[18], 0x8b8cd5b5), new Int_64(K_sha2[19], 0x77ac9c65),\n\t\t\t\tnew Int_64(K_sha2[20], 0x592b0275), new Int_64(K_sha2[21], 0x6ea6e483),\n\t\t\t\tnew Int_64(K_sha2[22], 0xbd41fbd4), new Int_64(K_sha2[23], 0x831153b5),\n\t\t\t\tnew Int_64(K_sha2[24], 0xee66dfab), new Int_64(K_sha2[25], 0x2db43210),\n\t\t\t\tnew Int_64(K_sha2[26], 0x98fb213f), new Int_64(K_sha2[27], 0xbeef0ee4),\n\t\t\t\tnew Int_64(K_sha2[28], 0x3da88fc2), new Int_64(K_sha2[29], 0x930aa725),\n\t\t\t\tnew Int_64(K_sha2[30], 0xe003826f), new Int_64(K_sha2[31], 0x0a0e6e70),\n\t\t\t\tnew Int_64(K_sha2[32], 0x46d22ffc), new Int_64(K_sha2[33], 0x5c26c926),\n\t\t\t\tnew Int_64(K_sha2[34], 0x5ac42aed), new Int_64(K_sha2[35], 0x9d95b3df),\n\t\t\t\tnew Int_64(K_sha2[36], 0x8baf63de), new Int_64(K_sha2[37], 0x3c77b2a8),\n\t\t\t\tnew Int_64(K_sha2[38], 0x47edaee6), new Int_64(K_sha2[39], 0x1482353b),\n\t\t\t\tnew Int_64(K_sha2[40], 0x4cf10364), new Int_64(K_sha2[41], 0xbc423001),\n\t\t\t\tnew Int_64(K_sha2[42], 0xd0f89791), new Int_64(K_sha2[43], 0x0654be30),\n\t\t\t\tnew Int_64(K_sha2[44], 0xd6ef5218), new Int_64(K_sha2[45], 0x5565a910),\n\t\t\t\tnew Int_64(K_sha2[46], 0x5771202a), new Int_64(K_sha2[47], 0x32bbd1b8),\n\t\t\t\tnew Int_64(K_sha2[48], 0xb8d2d0c8), new Int_64(K_sha2[49], 0x5141ab53),\n\t\t\t\tnew Int_64(K_sha2[50], 0xdf8eeb99), new Int_64(K_sha2[51], 0xe19b48a8),\n\t\t\t\tnew Int_64(K_sha2[52], 0xc5c95a63), new Int_64(K_sha2[53], 0xe3418acb),\n\t\t\t\tnew Int_64(K_sha2[54], 0x7763e373), new Int_64(K_sha2[55], 0xd6b2b8a3),\n\t\t\t\tnew Int_64(K_sha2[56], 0x5defb2fc), new Int_64(K_sha2[57], 0x43172f60),\n\t\t\t\tnew Int_64(K_sha2[58], 0xa1f0ab72), new Int_64(K_sha2[59], 0x1a6439ec),\n\t\t\t\tnew Int_64(K_sha2[60], 0x23631e28), new Int_64(K_sha2[61], 0xde82bde9),\n\t\t\t\tnew Int_64(K_sha2[62], 0xb2c67915), new Int_64(K_sha2[63], 0xe372532b),\n\t\t\t\tnew Int_64(0xca273ece, 0xea26619c), new Int_64(0xd186b8c7, 0x21c0c207),\n\t\t\t\tnew Int_64(0xeada7dd6, 0xcde0eb1e), new Int_64(0xf57d4f7f, 0xee6ed178),\n\t\t\t\tnew Int_64(0x06f067aa, 0x72176fba), new Int_64(0x0a637dc5, 0xa2c898a6),\n\t\t\t\tnew Int_64(0x113f9804, 0xbef90dae), new Int_64(0x1b710b35, 0x131c471b),\n\t\t\t\tnew Int_64(0x28db77f5, 0x23047d84), new Int_64(0x32caab7b, 0x40c72493),\n\t\t\t\tnew Int_64(0x3c9ebe0a, 0x15c9bebc), new Int_64(0x431d67c4, 0x9c100d4c),\n\t\t\t\tnew Int_64(0x4cc5d4be, 0xcb3e42b6), new Int_64(0x597f299c, 0xfc657e2a),\n\t\t\t\tnew Int_64(0x5fcb6fab, 0x3ad6faec), new Int_64(0x6c44198c, 0x4a475817)\n\t\t\t];\n\t\t}\n\t}\n\tif ((8 & SUPPORTED_ALGS) !== 0)\n\t{\n\t\trc_sha3 = [\n\t\t\tnew Int_64(0x00000000, 0x00000001), new Int_64(0x00000000, 0x00008082),\n\t\t\tnew Int_64(0x80000000, 0x0000808A), new Int_64(0x80000000, 0x80008000),\n\t\t\tnew Int_64(0x00000000, 0x0000808B), new Int_64(0x00000000, 0x80000001),\n\t\t\tnew Int_64(0x80000000, 0x80008081), new Int_64(0x80000000, 0x00008009),\n\t\t\tnew Int_64(0x00000000, 0x0000008A), new Int_64(0x00000000, 0x00000088),\n\t\t\tnew Int_64(0x00000000, 0x80008009), new Int_64(0x00000000, 0x8000000A),\n\t\t\tnew Int_64(0x00000000, 0x8000808B), new Int_64(0x80000000, 0x0000008B),\n\t\t\tnew Int_64(0x80000000, 0x00008089), new Int_64(0x80000000, 0x00008003),\n\t\t\tnew Int_64(0x80000000, 0x00008002), new Int_64(0x80000000, 0x00000080),\n\t\t\tnew Int_64(0x00000000, 0x0000800A), new Int_64(0x80000000, 0x8000000A),\n\t\t\tnew Int_64(0x80000000, 0x80008081), new Int_64(0x80000000, 0x00008080),\n\t\t\tnew Int_64(0x00000000, 0x80000001), new Int_64(0x80000000, 0x80008008)\n\t\t];\n\n\t\tr_sha3 = [\n\t\t\t[ 0, 36,  3, 41, 18],\n\t\t\t[ 1, 44, 10, 45,  2],\n\t\t\t[62,  6, 43, 15, 61],\n\t\t\t[28, 55, 25, 21, 56],\n\t\t\t[27, 20, 39,  8, 14]\n\t\t];\n\t}\n\n\t/**\n\t * Performs a round of SHA-2 hashing over a block\n\t *\n\t * @private\n\t * @param {Array<number>} block The binary array representation of the\n\t *   block to hash\n\t * @param {Array<number|Int_64>} H The intermediate H values from a previous\n\t *   round\n\t * @param {string} variant The desired SHA-2 variant\n\t * @return {Array<number|Int_64>} The resulting H values\n\t */\n\tfunction roundSHA2(block, H, variant)\n\t{\n\t\tvar a, b, c, d, e, f, g, h, T1, T2, numRounds, t, binaryStringMult,\n\t\t\tsafeAdd_2, safeAdd_4, safeAdd_5, gamma0, gamma1, sigma0, sigma1,\n\t\t\tch, maj, Int, W = [], int1, int2, offset, K;\n\n\t\t/* Set up the various function handles and variable for the specific\n\t\t * variant */\n\t\tif ((variant === \"SHA-224\" || variant === \"SHA-256\") &&\n\t\t\t((2 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\t/* 32-bit variant */\n\t\t\tnumRounds = 64;\n\t\t\tbinaryStringMult = 1;\n\t\t\tInt = Number;\n\t\t\tsafeAdd_2 = safeAdd_32_2;\n\t\t\tsafeAdd_4 = safeAdd_32_4;\n\t\t\tsafeAdd_5 = safeAdd_32_5;\n\t\t\tgamma0 = gamma0_32;\n\t\t\tgamma1 = gamma1_32;\n\t\t\tsigma0 = sigma0_32;\n\t\t\tsigma1 = sigma1_32;\n\t\t\tmaj = maj_32;\n\t\t\tch = ch_32;\n\t\t\tK = K_sha2;\n\t\t}\n\t\telse if ((variant === \"SHA-384\" || variant === \"SHA-512\") &&\n\t\t\t((4 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\t/* 64-bit variant */\n\t\t\tnumRounds = 80;\n\t\t\tbinaryStringMult = 2;\n\t\t\tInt = Int_64;\n\t\t\tsafeAdd_2 = safeAdd_64_2;\n\t\t\tsafeAdd_4 = safeAdd_64_4;\n\t\t\tsafeAdd_5 = safeAdd_64_5;\n\t\t\tgamma0 = gamma0_64;\n\t\t\tgamma1 = gamma1_64;\n\t\t\tsigma0 = sigma0_64;\n\t\t\tsigma1 = sigma1_64;\n\t\t\tmaj = maj_64;\n\t\t\tch = ch_64;\n\t\t\tK = K_sha512;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new Error(\"Unexpected error in SHA-2 implementation\");\n\t\t}\n\n\t\ta = H[0];\n\t\tb = H[1];\n\t\tc = H[2];\n\t\td = H[3];\n\t\te = H[4];\n\t\tf = H[5];\n\t\tg = H[6];\n\t\th = H[7];\n\n\t\tfor (t = 0; t < numRounds; t += 1)\n\t\t{\n\t\t\tif (t < 16)\n\t\t\t{\n\t\t\t\toffset = t * binaryStringMult;\n\t\t\t\tint1 = (block.length <= offset) ? 0 : block[offset];\n\t\t\t\tint2 = (block.length <= offset + 1) ? 0 : block[offset + 1];\n\t\t\t\t/* Bit of a hack - for 32-bit, the second term is ignored */\n\t\t\t\tW[t] = new Int(int1, int2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tW[t] = safeAdd_4(\n\t\t\t\t\t\tgamma1(W[t - 2]), W[t - 7],\n\t\t\t\t\t\tgamma0(W[t - 15]), W[t - 16]\n\t\t\t\t\t);\n\t\t\t}\n\n\t\t\tT1 = safeAdd_5(h, sigma1(e), ch(e, f, g), K[t], W[t]);\n\t\t\tT2 = safeAdd_2(sigma0(a), maj(a, b, c));\n\t\t\th = g;\n\t\t\tg = f;\n\t\t\tf = e;\n\t\t\te = safeAdd_2(d, T1);\n\t\t\td = c;\n\t\t\tc = b;\n\t\t\tb = a;\n\t\t\ta = safeAdd_2(T1, T2);\n\t\t}\n\n\t\tH[0] = safeAdd_2(a, H[0]);\n\t\tH[1] = safeAdd_2(b, H[1]);\n\t\tH[2] = safeAdd_2(c, H[2]);\n\t\tH[3] = safeAdd_2(d, H[3]);\n\t\tH[4] = safeAdd_2(e, H[4]);\n\t\tH[5] = safeAdd_2(f, H[5]);\n\t\tH[6] = safeAdd_2(g, H[6]);\n\t\tH[7] = safeAdd_2(h, H[7]);\n\n\t\treturn H;\n\t}\n\n\t/**\n\t * Finalizes the SHA-2 hash\n\t *\n\t * @private\n\t * @param {Array<number>} remainder Any leftover unprocessed packed ints\n\t *   that still need to be processed\n\t * @param {number} remainderBinLen The number of bits in remainder\n\t * @param {number} processedBinLen The number of bits already\n\t *   processed\n\t * @param {Array<number|Int_64>} H The intermediate H values from a previous\n\t *   round\n\t * @param {string} variant The desired SHA-2 variant\n\t * @param {number} outputLen Unused for this variant\n\t * @return {Array<number>} The array of integers representing the SHA-2\n\t *   hash of message\n\t */\n\tfunction finalizeSHA2(remainder, remainderBinLen, processedBinLen, H, variant, outputLen)\n\t{\n\t\tvar i, appendedMessageLength, offset, retVal, binaryStringInc, totalLen;\n\n\t\tif ((variant === \"SHA-224\" || variant === \"SHA-256\") &&\n\t\t\t((2 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\t/* 32-bit variant */\n\t\t\t/* The 65 addition is a hack but it works.  The correct number is\n\t\t\t   actually 72 (64 + 8) but the below math fails if\n\t\t\t   remainderBinLen + 72 % 512 = 0. Since remainderBinLen % 8 = 0,\n\t\t\t   \"shorting\" the addition is OK. */\n\t\t\toffset = (((remainderBinLen + 65) >>> 9) << 4) + 15;\n\t\t\tbinaryStringInc = 16;\n\t\t}\n\t\telse if ((variant === \"SHA-384\" || variant === \"SHA-512\") &&\n\t\t\t((4 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\t/* 64-bit variant */\n\t\t\t/* The 129 addition is a hack but it works.  The correct number is\n\t\t\t   actually 136 (128 + 8) but the below math fails if\n\t\t\t   remainderBinLen + 136 % 1024 = 0. Since remainderBinLen % 8 = 0,\n\t\t\t   \"shorting\" the addition is OK. */\n\t\t\toffset = (((remainderBinLen + 129) >>> 10) << 5) + 31;\n\t\t\tbinaryStringInc = 32;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new Error(\"Unexpected error in SHA-2 implementation\");\n\t\t}\n\n\t\twhile (remainder.length <= offset)\n\t\t{\n\t\t\tremainder.push(0);\n\t\t}\n\t\t/* Append '1' at the end of the binary string */\n\t\tremainder[remainderBinLen >>> 5] |= 0x80 << (24 - remainderBinLen % 32);\n\t\t/* Append length of binary string in the position such that the new\n\t\t * length is correct. JavaScript numbers are limited to 2^53 so it's\n\t\t * \"safe\" to treat the totalLen as a 64-bit integer. */\n\t\ttotalLen = remainderBinLen + processedBinLen;\n\t\tremainder[offset] = totalLen & 0xFFFFFFFF;\n\t\t/* Bitwise operators treat the operand as a 32-bit number so need to\n\t\t * use hacky division and round to get access to upper 32-ish bits */\n\t\tremainder[offset - 1] = (totalLen / TWO_PWR_32) | 0;\n\n\t\tappendedMessageLength = remainder.length;\n\n\t\t/* This will always be at least 1 full chunk */\n\t\tfor (i = 0; i < appendedMessageLength; i += binaryStringInc)\n\t\t{\n\t\t\tH = roundSHA2(remainder.slice(i, i + binaryStringInc), H, variant);\n\t\t}\n\n\t\tif ((\"SHA-224\" === variant) && ((2 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tretVal = [\n\t\t\t\tH[0], H[1], H[2], H[3],\n\t\t\t\tH[4], H[5], H[6]\n\t\t\t];\n\t\t}\n\t\telse if ((\"SHA-256\" === variant) && ((2 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tretVal = H;\n\t\t}\n\t\telse if ((\"SHA-384\" === variant) && ((4 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tretVal = [\n\t\t\t\tH[0].highOrder, H[0].lowOrder,\n\t\t\t\tH[1].highOrder, H[1].lowOrder,\n\t\t\t\tH[2].highOrder, H[2].lowOrder,\n\t\t\t\tH[3].highOrder, H[3].lowOrder,\n\t\t\t\tH[4].highOrder, H[4].lowOrder,\n\t\t\t\tH[5].highOrder, H[5].lowOrder\n\t\t\t];\n\t\t}\n\t\telse if ((\"SHA-512\" === variant) && ((4 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tretVal = [\n\t\t\t\tH[0].highOrder, H[0].lowOrder,\n\t\t\t\tH[1].highOrder, H[1].lowOrder,\n\t\t\t\tH[2].highOrder, H[2].lowOrder,\n\t\t\t\tH[3].highOrder, H[3].lowOrder,\n\t\t\t\tH[4].highOrder, H[4].lowOrder,\n\t\t\t\tH[5].highOrder, H[5].lowOrder,\n\t\t\t\tH[6].highOrder, H[6].lowOrder,\n\t\t\t\tH[7].highOrder, H[7].lowOrder\n\t\t\t];\n\t\t}\n\t\telse /* This should never be reached */\n\t\t{\n\t\t\tthrow new Error(\"Unexpected error in SHA-2 implementation\");\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * Performs a round of SHA-3 hashing over a block\n\t *\n\t * @private\n\t * @param {Array<number>|null} block The binary array representation of the\n\t *   block to hash\n\t * @param {Array<Array<Int_64>>} state The binary array representation of the\n\t *   block to hash\n\t * @return {Array<Array<Int_64>>} The resulting state value\n\t */\n\tfunction roundSHA3(block, state)\n\t{\n\t\tvar round, x, y, B, C = [], D = [];\n\n\t\tif (null !== block)\n\t\t{\n\t\t\tfor (x = 0; x < block.length; x+=2)\n\t\t\t{\n\t\t\t\tstate[(x >>> 1) % 5][((x >>> 1) / 5) | 0] = xor_64_2(\n\t\t\t\t\tstate[(x >>> 1) % 5][((x >>> 1) / 5) | 0],\n\t\t\t\t\tnew Int_64(block[x + 1], block[x])\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tfor (round = 0; round < 24; round += 1)\n\t\t{\n\t\t\t/* getNewState doesn't care about variant beyond SHA3 so feed it a\n\t\t\t   value that triggers the getNewState \"if\" statement\n\t\t\t*/\n\t\t\tB = getNewState(\"SHA3-\");\n\n\t\t\t/* Perform theta step */\n\t\t\tfor (x = 0; x < 5; x += 1)\n\t\t\t{\n\t\t\t\tC[x] = xor_64_5(state[x][0], state[x][1], state[x][2],\n\t\t\t\t\tstate[x][3], state[x][4]);\n\t\t\t}\n\t\t\tfor (x = 0; x < 5; x += 1)\n\t\t\t{\n\t\t\t\tD[x] = xor_64_2(C[(x + 4) % 5], rotl_64(C[(x + 1) % 5], 1));\n\t\t\t}\n\t\t\tfor (x = 0; x < 5; x += 1)\n\t\t\t{\n\t\t\t\tfor (y = 0; y < 5; y += 1)\n\t\t\t\t{\n\t\t\t\t\tstate[x][y] = xor_64_2(state[x][y], D[x]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Perform combined ro and pi steps */\n\t\t\tfor (x = 0; x < 5; x += 1)\n\t\t\t{\n\t\t\t\tfor (y = 0; y < 5; y += 1)\n\t\t\t\t{\n\t\t\t\t\tB[y][(2 * x + 3 * y) % 5] = rotl_64(\n\t\t\t\t\t\tstate[x][y],\n\t\t\t\t\t\tr_sha3[x][y]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Perform chi step */\n\t\t\tfor (x = 0; x < 5; x += 1)\n\t\t\t{\n\t\t\t\tfor (y = 0; y < 5; y += 1)\n\t\t\t\t{\n\t\t\t\t\tstate[x][y] = xor_64_2(\n\t\t\t\t\t\tB[x][y],\n\t\t\t\t\t\tnew Int_64(\n\t\t\t\t\t\t\t~(B[(x + 1) % 5][y].highOrder) & B[(x + 2) % 5][y].highOrder,\n\t\t\t\t\t\t\t~(B[(x + 1) % 5][y].lowOrder)  & B[(x + 2) % 5][y].lowOrder\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Perform iota step */\n\t\t\tstate[0][0] = xor_64_2(state[0][0], rc_sha3[round]);\n\t\t}\n\n\t\treturn state;\n\t}\n\n\t/**\n\t * Finalizes the SHA-3 hash\n\t *\n\t * @private\n\t * @param {Array<number>} remainder Any leftover unprocessed packed ints\n\t *   that still need to be processed\n\t * @param {number} remainderBinLen The number of bits in remainder\n\t * @param {number} processedBinLen The number of bits already\n\t *   processed\n\t * @param {Array<Array<Int_64>>} state The state from a previous round\n\t * @param {number} blockSize The block size/rate of the variant in bits\n\t * @param {number} delimiter The delimiter value for the variant\n\t * @param {number} outputLen The output length for the variant in bits\n\t * @return {Array<number>} The array of integers representing the SHA-3\n\t *   hash of message\n\t */\n\tfunction finalizeSHA3(remainder, remainderBinLen, processedBinLen, state, blockSize, delimiter, outputLen)\n\t{\n\t\tvar i, retVal = [], binaryStringInc = blockSize >>> 5, state_offset = 0,\n\t\t\tremainderIntLen = remainderBinLen >>> 5, temp;\n\n\n\t\t/* Process as many blocks as possible, some may be here for multiple rounds\n\t\t   with SHAKE\n\t\t*/\n\t\tfor (i = 0; i < remainderIntLen && remainderBinLen >= blockSize; i += binaryStringInc)\n\t\t{\n\t\t\tstate = roundSHA3(remainder.slice(i, i + binaryStringInc), state);\n\t\t\tremainderBinLen -= blockSize;\n\t\t}\n\n\t\tremainder = remainder.slice(i);\n\t\tremainderBinLen = remainderBinLen % blockSize;\n\n\t\t/* Pad out the remainder to a full block */\n\t\twhile (remainder.length < binaryStringInc)\n\t\t{\n\t\t\tremainder.push(0);\n\t\t}\n\n\t\t/* Find the next \"empty\" byte for the 0x80 and append it via an xor */\n\t\ti = remainderBinLen >>> 3;\n\t\tremainder[i >> 2] ^= delimiter << (8 * (i % 4));\n\n\t\tremainder[binaryStringInc - 1] ^= 0x80000000;\n\t\tstate = roundSHA3(remainder, state);\n\n\t\twhile (retVal.length * 32 < outputLen)\n\t\t{\n\t\t\ttemp = state[state_offset % 5][(state_offset / 5) | 0];\n\t\t\tretVal.push(temp.lowOrder);\n\t\t\tif (retVal.length * 32 >= outputLen)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretVal.push(temp.highOrder);\n\t\t\tstate_offset += 1;\n\n\t\t\tif (0 === ((state_offset * 64) % blockSize))\n\t\t\t{\n\t\t\t\troundSHA3(null, state);\n\t\t\t}\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * jsSHA is the workhorse of the library.  Instantiate it with the string to\n\t * be hashed as the parameter\n\t *\n\t * @constructor\n\t * @this {jsSHA}\n\t * @param {string} variant The desired SHA variant (SHA-1, SHA-224, SHA-256,\n\t *   SHA-384, SHA-512, SHA3-224, SHA3-256, SHA3-384, or SHA3-512)\n\t * @param {string} inputFormat The format of srcString: HEX, TEXT, B64,\n\t *   BYTES, or ARRAYBUFFER\n\t * @param {{encoding: (string|undefined), numRounds: (number|undefined)}=}\n\t *   options Optional values\n\t */\n\tvar jsSHA = function(variant, inputFormat, options)\n\t{\n\t\tvar processedLen = 0, remainder = [], remainderLen = 0, utfType,\n\t\t\tintermediateState, converterFunc, shaVariant = variant, outputBinLen,\n\t\t\tvariantBlockSize, roundFunc, finalizeFunc, stateCloneFunc,\n\t\t\thmacKeySet = false, keyWithIPad = [], keyWithOPad = [], numRounds,\n\t\t\tupdatedCalled = false, inputOptions, isSHAKE = false, bigEndianMod = -1;\n\n\t\tinputOptions = options || {};\n\t\tutfType = inputOptions[\"encoding\"] || \"UTF8\";\n\t\tnumRounds = inputOptions[\"numRounds\"] || 1;\n\n\t\tif ((numRounds !== parseInt(numRounds, 10)) || (1 > numRounds))\n\t\t{\n\t\t\tthrow new Error(\"numRounds must a integer >= 1\");\n\t\t}\n\n\t\tif ((\"SHA-1\" === shaVariant) && ((1 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tvariantBlockSize = 512;\n\t\t\troundFunc = roundSHA1;\n\t\t\tfinalizeFunc = finalizeSHA1;\n\t\t\toutputBinLen = 160;\n\t\t\tstateCloneFunc = function(state) { return state.slice();};\n\t\t}\n\t\telse if ((shaVariant.lastIndexOf(\"SHA-\", 0) === 0) && ((6 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\troundFunc = function (block, H) {\n\t\t\t\treturn roundSHA2(block, H, shaVariant);\n\t\t\t};\n\t\t\tfinalizeFunc = function (remainder, remainderBinLen, processedBinLen, H, outputLen)\n\t\t\t{\n\t\t\t\treturn finalizeSHA2(remainder, remainderBinLen, processedBinLen, H, shaVariant, outputLen);\n\t\t\t};\n\t\t\tstateCloneFunc = function(state) { return state.slice(); };\n\n\t\t\tif ((\"SHA-224\" === shaVariant) && ((2 & SUPPORTED_ALGS) !== 0))\n\t\t\t{\n\t\t\t\tvariantBlockSize = 512;\n\t\t\t\toutputBinLen = 224;\n\t\t\t}\n\t\t\telse if ((\"SHA-256\" === shaVariant) && ((2 & SUPPORTED_ALGS) !== 0))\n\t\t\t{\n\t\t\t\tvariantBlockSize = 512;\n\t\t\t\toutputBinLen = 256;\n\t\t\t}\n\t\t\telse if ((\"SHA-384\" === shaVariant) && ((4 & SUPPORTED_ALGS) !== 0))\n\t\t\t{\n\t\t\t\tvariantBlockSize = 1024;\n\t\t\t\toutputBinLen = 384;\n\t\t\t}\n\t\t\telse if ((\"SHA-512\" === shaVariant) && ((4 & SUPPORTED_ALGS) !== 0))\n\t\t\t{\n\t\t\t\tvariantBlockSize = 1024;\n\t\t\t\toutputBinLen = 512;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new Error(\"Chosen SHA variant is not supported\");\n\t\t\t}\n\t\t}\n\t\telse if (((shaVariant.lastIndexOf(\"SHA3-\", 0) === 0) || (shaVariant.lastIndexOf(\"SHAKE\", 0) === 0)) &&\n\t\t\t((8 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tvar delimiter = 0x06;\n\n\t\t\troundFunc = roundSHA3;\n\t\t\tstateCloneFunc = function(state) { return cloneSHA3State(state);};\n\t\t\tbigEndianMod = 1;\n\n\t\t\tif (\"SHA3-224\" === shaVariant)\n\t\t\t{\n\t\t\t\tvariantBlockSize = 1152;\n\t\t\t\toutputBinLen = 224;\n\n\t\t\t}\n\t\t\telse if (\"SHA3-256\" === shaVariant)\n\t\t\t{\n\t\t\t\tvariantBlockSize = 1088;\n\t\t\t\toutputBinLen = 256;\n\t\t\t}\n\t\t\telse if (\"SHA3-384\" === shaVariant)\n\t\t\t{\n\t\t\t\tvariantBlockSize = 832;\n\t\t\t\toutputBinLen = 384;\n\t\t\t}\n\t\t\telse if (\"SHA3-512\" === shaVariant)\n\t\t\t{\n\t\t\t\tvariantBlockSize = 576;\n\t\t\t\toutputBinLen = 512;\n\t\t\t}\n\t\t\telse if (\"SHAKE128\" === shaVariant)\n\t\t\t{\n\t\t\t\tvariantBlockSize = 1344;\n\t\t\t\toutputBinLen = -1;\n\t\t\t\tdelimiter = 0x1F;\n\t\t\t\tisSHAKE = true;\n\t\t\t}\n\t\t\telse if (\"SHAKE256\" === shaVariant)\n\t\t\t{\n\t\t\t\tvariantBlockSize = 1088;\n\t\t\t\toutputBinLen = -1;\n\t\t\t\tdelimiter = 0x1F;\n\t\t\t\tisSHAKE = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new Error(\"Chosen SHA variant is not supported\");\n\t\t\t}\n\t\t\tfinalizeFunc = function (remainder, remainderBinLen, processedBinLen, state, outputLen)\n\t\t\t{\n\t\t\t\treturn finalizeSHA3(remainder, remainderBinLen, processedBinLen, state, variantBlockSize, delimiter, outputLen);\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new Error(\"Chosen SHA variant is not supported\");\n\t\t}\n\t\tconverterFunc = getStrConverter(inputFormat, utfType, bigEndianMod);\n\t\tintermediateState = getNewState(shaVariant);\n\n\t\t/**\n\t\t * Sets the HMAC key for an eventual getHMAC call.  Must be called\n\t\t * immediately after jsSHA object instantiation\n\t\t *\n\t\t * @expose\n\t\t * @param {string|ArrayBuffer} key The key used to calculate the HMAC\n\t\t * @param {string} inputFormat The format of key, HEX, TEXT, B64, BYTES,\n\t\t *   or ARRAYBUFFER\n\t\t * @param {{encoding : (string|undefined)}=} options Associative array\n\t\t *   of input format options\n\t\t */\n\t\tthis.setHMACKey = function(key, inputFormat, options)\n\t\t{\n\t\t\tvar keyConverterFunc, convertRet, keyBinLen, keyToUse, blockByteSize,\n\t\t\t\ti, lastArrayIndex, keyOptions;\n\n\t\t\tif (true === hmacKeySet)\n\t\t\t{\n\t\t\t\tthrow new Error(\"HMAC key already set\");\n\t\t\t}\n\n\t\t\tif (true === updatedCalled)\n\t\t\t{\n\t\t\t\tthrow new Error(\"Cannot set HMAC key after calling update\");\n\t\t\t}\n\n\t\t\tif ((isSHAKE === true) && ((8 & SUPPORTED_ALGS) !== 0))\n\t\t\t{\n\t\t\t\tthrow new Error(\"SHAKE is not supported for HMAC\");\n\t\t\t}\n\n\t\t\tkeyOptions = options || {};\n\t\t\tutfType = keyOptions[\"encoding\"] || \"UTF8\";\n\n\t\t\tkeyConverterFunc = getStrConverter(inputFormat, utfType, bigEndianMod);\n\n\t\t\tconvertRet = keyConverterFunc(key);\n\t\t\tkeyBinLen = convertRet[\"binLen\"];\n\t\t\tkeyToUse = convertRet[\"value\"];\n\n\t\t\tblockByteSize = variantBlockSize >>> 3;\n\n\t\t\t/* These are used multiple times, calculate and store them */\n\t\t\tlastArrayIndex = (blockByteSize / 4) - 1;\n\n\t\t\t/* Figure out what to do with the key based on its size relative to\n\t\t\t * the hash's block size */\n\t\t\tif (blockByteSize < (keyBinLen / 8))\n\t\t\t{\n\n\t\t\t\tkeyToUse = finalizeFunc(keyToUse, keyBinLen, 0,getNewState(shaVariant), outputBinLen);\n\t\t\t\t/* For all variants, the block size is bigger than the output\n\t\t\t\t * size so there will never be a useful byte at the end of the\n\t\t\t\t * string */\n\t\t\t\twhile (keyToUse.length <= lastArrayIndex)\n\t\t\t\t{\n\t\t\t\t\tkeyToUse.push(0);\n\t\t\t\t}\n\t\t\t\tkeyToUse[lastArrayIndex] &= 0xFFFFFF00;\n\t\t\t}\n\t\t\telse if (blockByteSize > (keyBinLen / 8))\n\t\t\t{\n\t\t\t\t/* If the blockByteSize is greater than the key length, there\n\t\t\t\t * will always be at LEAST one \"useless\" byte at the end of the\n\t\t\t\t * string */\n\t\t\t\twhile (keyToUse.length <= lastArrayIndex)\n\t\t\t\t{\n\t\t\t\t\tkeyToUse.push(0);\n\t\t\t\t}\n\t\t\t\tkeyToUse[lastArrayIndex] &= 0xFFFFFF00;\n\t\t\t}\n\n\t\t\t/* Create ipad and opad */\n\t\t\tfor (i = 0; i <= lastArrayIndex; i += 1)\n\t\t\t{\n\t\t\t\tkeyWithIPad[i] = keyToUse[i] ^ 0x36363636;\n\t\t\t\tkeyWithOPad[i] = keyToUse[i] ^ 0x5C5C5C5C;\n\t\t\t}\n\n\t\t\tintermediateState = roundFunc(keyWithIPad, intermediateState);\n\t\t\tprocessedLen = variantBlockSize;\n\n\t\t\thmacKeySet = true;\n\t\t};\n\n\t\t/**\n\t\t * Takes strString and hashes as many blocks as possible.  Stores the\n\t\t * rest for either a future update or getHash call.\n\t\t *\n\t\t * @expose\n\t\t * @param {string|ArrayBuffer} srcString The string to be hashed\n\t\t */\n\t\tthis.update = function(srcString)\n\t\t{\n\t\t\tvar convertRet, chunkBinLen, chunkIntLen, chunk, i, updateProcessedLen = 0,\n\t\t\t\tvariantBlockIntInc = variantBlockSize >>> 5;\n\n\t\t\tconvertRet = converterFunc(srcString, remainder, remainderLen);\n\t\t\tchunkBinLen = convertRet[\"binLen\"];\n\t\t\tchunk = convertRet[\"value\"];\n\n\t\t\tchunkIntLen = chunkBinLen >>> 5;\n\t\t\tfor (i = 0; i < chunkIntLen; i += variantBlockIntInc)\n\t\t\t{\n\t\t\t\tif (updateProcessedLen + variantBlockSize <= chunkBinLen)\n\t\t\t\t{\n\t\t\t\t\tintermediateState = roundFunc(\n\t\t\t\t\t\tchunk.slice(i, i + variantBlockIntInc),\n\t\t\t\t\t\tintermediateState\n\t\t\t\t\t);\n\t\t\t\t\tupdateProcessedLen += variantBlockSize;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessedLen += updateProcessedLen;\n\t\t\tremainder = chunk.slice(updateProcessedLen >>> 5);\n\t\t\tremainderLen = chunkBinLen % variantBlockSize;\n\t\t\tupdatedCalled = true;\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the desired SHA hash of the string specified at instantiation\n\t\t * using the specified parameters\n\t\t *\n\t\t * @expose\n\t\t * @param {string} format The desired output formatting (B64, HEX,\n\t\t *   BYTES, or ARRAYBUFFER)\n\t\t * @param {{outputUpper : (boolean|undefined), b64Pad : (string|undefined),\n\t\t *   shakeLen : (number|undefined)}=} options Hash list of output formatting options\n\t\t * @return {string|ArrayBuffer} The string representation of the hash\n\t\t *   in the format specified.\n\t\t */\n\t\tthis.getHash = function(format, options)\n\t\t{\n\t\t\tvar formatFunc, i, outputOptions, finalizedState;\n\n\t\t\tif (true === hmacKeySet)\n\t\t\t{\n\t\t\t\tthrow new Error(\"Cannot call getHash after setting HMAC key\");\n\t\t\t}\n\n\t\t\toutputOptions = getOutputOpts(options);\n\n\t\t\tif ((isSHAKE === true) && ((8 & SUPPORTED_ALGS) !== 0))\n\t\t\t{\n\t\t\t\tif (outputOptions[\"shakeLen\"] === -1)\n\t\t\t\t{\n\t\t\t\t\tthrow new Error(\"shakeLen must be specified in options\");\n\t\t\t\t}\n\t\t\t\toutputBinLen = outputOptions[\"shakeLen\"];\n\t\t\t}\n\n\t\t\t/* Validate the output format selection */\n\t\t\tswitch (format)\n\t\t\t{\n\t\t\tcase \"HEX\":\n\t\t\t\tformatFunc = function(binarray) {return packed2hex(binarray, outputBinLen, bigEndianMod, outputOptions);};\n\t\t\t\tbreak;\n\t\t\tcase \"B64\":\n\t\t\t\tformatFunc = function(binarray) {return packed2b64(binarray, outputBinLen, bigEndianMod, outputOptions);};\n\t\t\t\tbreak;\n\t\t\tcase \"BYTES\":\n\t\t\t\tformatFunc = function(binarray) {return packed2bytes(binarray, outputBinLen, bigEndianMod);};\n\t\t\t\tbreak;\n\t\t\tcase \"ARRAYBUFFER\":\n\t\t\t\ttry {\n\t\t\t\t\ti = new ArrayBuffer(0);\n\t\t\t\t} catch (ignore) {\n\t\t\t\t\tthrow new Error(\"ARRAYBUFFER not supported by this environment\");\n\t\t\t\t}\n\t\t\t\tformatFunc = function(binarray) {return packed2arraybuffer(binarray, outputBinLen, bigEndianMod);};\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"format must be HEX, B64, BYTES, or ARRAYBUFFER\");\n\t\t\t}\n\n\t\t\tfinalizedState = finalizeFunc(remainder.slice(), remainderLen, processedLen, stateCloneFunc(intermediateState), outputBinLen);\n\t\t\tfor (i = 1; i < numRounds; i += 1)\n\t\t\t{\n\t\t\t\t/* This weird fix-up is only for the case of SHAKE algorithms\n\t\t\t\t * and outputBinLen is not a multiple of 32.  In this case, the\n\t\t\t\t * very last block of finalizedState has data that needs to be\n\t\t\t\t * ignored because all the finalizeFunc calls need to have\n\t\t\t\t * unneeded bits set to 0.\n\t\t\t\t */\n\t\t\t\tif (((8 & SUPPORTED_ALGS) !== 0) && (isSHAKE === true) && (outputBinLen % 32 !== 0))\n\t\t\t\t{\n\t\t\t\t\tfinalizedState[finalizedState.length - 1] &= 0x00FFFFFF >>> 24 - (outputBinLen % 32);\n\t\t\t\t}\n\t\t\t\tfinalizedState = finalizeFunc(finalizedState, outputBinLen, 0, getNewState(shaVariant), outputBinLen);\n\t\t\t}\n\n\t\t\treturn formatFunc(finalizedState);\n\t\t};\n\n\t\t/**\n\t\t * Returns the the HMAC in the specified format using the key given by\n\t\t * a previous setHMACKey call.\n\t\t *\n\t\t * @expose\n\t\t * @param {string} format The desired output formatting\n\t\t *   (B64, HEX, BYTES, or ARRAYBUFFER)\n\t\t * @param {{outputUpper : (boolean|undefined), b64Pad : (string|undefined),\n\t\t *   shakeLen : (number|undefined)}=} options associative array of output\n\t\t *   formatting options\n\t\t * @return {string|ArrayBuffer} The string representation of the hash in the\n\t\t *   format specified.\n\t\t */\n\t\tthis.getHMAC = function(format, options)\n\t\t{\n\t\t\tvar formatFunc,\tfirstHash, outputOptions, finalizedState;\n\n\t\t\tif (false === hmacKeySet)\n\t\t\t{\n\t\t\t\tthrow new Error(\"Cannot call getHMAC without first setting HMAC key\");\n\t\t\t}\n\n\t\t\toutputOptions = getOutputOpts(options);\n\n\t\t\t/* Validate the output format selection */\n\t\t\tswitch (format)\n\t\t\t{\n\t\t\tcase \"HEX\":\n\t\t\t\tformatFunc = function(binarray) {return packed2hex(binarray, outputBinLen, bigEndianMod, outputOptions);};\n\t\t\t\tbreak;\n\t\t\tcase \"B64\":\n\t\t\t\tformatFunc = function(binarray) {return packed2b64(binarray, outputBinLen, bigEndianMod, outputOptions);};\n\t\t\t\tbreak;\n\t\t\tcase \"BYTES\":\n\t\t\t\tformatFunc = function(binarray) {return packed2bytes(binarray, outputBinLen, bigEndianMod);};\n\t\t\t\tbreak;\n\t\t\tcase \"ARRAYBUFFER\":\n\t\t\t\ttry {\n\t\t\t\t\tformatFunc = new ArrayBuffer(0);\n\t\t\t\t} catch(ignore) {\n\t\t\t\t\tthrow new Error(\"ARRAYBUFFER not supported by this environment\");\n\t\t\t\t}\n\t\t\t\tformatFunc = function(binarray) {return packed2arraybuffer(binarray, outputBinLen, bigEndianMod);};\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"outputFormat must be HEX, B64, BYTES, or ARRAYBUFFER\");\n\t\t\t}\n\n\t\t\tfirstHash = finalizeFunc(remainder.slice(), remainderLen, processedLen, stateCloneFunc(intermediateState), outputBinLen);\n\t\t\tfinalizedState = roundFunc(keyWithOPad, getNewState(shaVariant));\n\t\t\tfinalizedState = finalizeFunc(firstHash, outputBinLen, variantBlockSize, finalizedState, outputBinLen);\n\n\t\t\treturn formatFunc(finalizedState);\n\t\t};\n\t};\n\n\tif ((\"function\" === typeof define) && (define[\"amd\"])) /* AMD Support */\n\t{\n\t\tdefine(function()\n\t\t{\n\t\t\treturn jsSHA;\n\t\t});\n\t} else if (\"undefined\" !== typeof exports) /* Node Support */\n\t{\n\t\tif ((\"undefined\" !== typeof module) && module[\"exports\"])\n\t\t{\n\t\t  module[\"exports\"] = jsSHA;\n\t\t  exports = jsSHA;\n\t\t}\n\t\telse {\n\t\t\texports = jsSHA;\n\t\t}\n\t} else { /* Browsers and Web Workers*/\n\t\tglobal[\"jsSHA\"] = jsSHA;\n\t}\n}(this));\n"]}