{"version":3,"sources":["../vendor/jssha/src/sha_dev.js"],"names":["SUPPORTED_ALGS","global","Int_64","msint_32","lsint_32","this","highOrder","lowOrder","str2packed","str","utfType","existingPacked","existingPackedLen","bigEndianMod","packed","codePnt","codePntArr","i","j","existingByteLen","intOffset","byteOffset","shiftModifier","transposeBytes","byteCnt","length","charCodeAt","push","value","binLen","hex2packed","num","Error","parseInt","substr","isNaN","bytes2packed","b642packed","index","tmpInt","strPart","firstEqual","b64Tab","search","indexOf","replace","arraybuffer2packed","arr","arrView","Uint8Array","byteLength","packed2hex","outputLength","formatOpts","srcByte","hex_tab","charAt","toUpperCase","packed2b64","triplet","int1","int2","packed2bytes","String","fromCharCode","packed2arraybuffer","retVal","ArrayBuffer","getOutputOpts","options","outputOptions","outputUpper","b64Pad","shakeLen","hasOwnProperty","getStrConverter","format","existingBin","existingBinLen","ignore","rotl_32","x","n","rotl_64","rotr_32","rotr_64","tmp","shr_32","shr_64","parity_32","y","z","ch_32","ch_64","maj_32","maj_64","sigma0_32","sigma0_64","rotr28","rotr34","rotr39","sigma1_32","sigma1_64","rotr14","rotr18","rotr41","gamma0_32","gamma0_64","rotr1","rotr8","shr7","gamma1_32","gamma1_64","rotr19","rotr61","shr6","safeAdd_32_2","a","b","lsw","msw","safeAdd_32_4","c","d","safeAdd_32_5","e","safeAdd_64_2","safeAdd_64_4","safeAdd_64_5","xor_64_2","xor_64_5","cloneSHA3State","state","clone","slice","getNewState","variant","H_trunc","H_full","lastIndexOf","roundSHA1","block","H","T","t","W","ch","parity","maj","rotl","safeAdd_2","safeAdd_5","finalizeSHA1","remainder","remainderBinLen","processedBinLen","outputLen","appendedMessageLength","offset","totalLen","TWO_PWR_32","roundSHA2","f","g","h","T1","T2","numRounds","binaryStringMult","safeAdd_4","gamma0","gamma1","sigma0","sigma1","Int","K","K_sha512","Number","K_sha2","finalizeSHA2","binaryStringInc","roundSHA3","round","B","C","D","r_sha3","rc_sha3","finalizeSHA3","blockSize","delimiter","temp","state_offset","remainderIntLen","jsSHA","inputFormat","intermediateState","converterFunc","outputBinLen","variantBlockSize","roundFunc","finalizeFunc","stateCloneFunc","inputOptions","processedLen","remainderLen","shaVariant","hmacKeySet","keyWithIPad","keyWithOPad","updatedCalled","isSHAKE","setHMACKey","key","keyConverterFunc","convertRet","keyBinLen","keyToUse","blockByteSize","lastArrayIndex","keyOptions","update","srcString","chunkBinLen","chunkIntLen","chunk","updateProcessedLen","variantBlockIntInc","getHash","formatFunc","finalizedState","binarray","getHMAC","firstHash","define","exports","module","definition","path","Failure","iterate","isObject","isEnabled","match","settings","demand","on","dependency","sha","hash","type","source","dfd","reject","id","error","provide"],"mappings":"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","file":"sri.js","sourcesContent":["/**\n * @preserve A JavaScript implementation of the SHA family of hashes, as\n * defined in FIPS PUB 180-4 and FIPS PUB 202, as well as the corresponding\n * HMAC implementation as defined in FIPS PUB 198a\n *\n * Copyright Brian Turek 2008-2017\n * Distributed under the BSD License\n * See http://caligatio.github.com/jsSHA/ for more information\n *\n * Several functions taken from Paul Johnston\n */\n\n/*jslint\n\tbitwise: true, multivar: true, for: true, this: true, sub: true, esversion: 3\n*/\n\n /**\n  * SUPPORTED_ALGS is the stub for a compile flag that will cause pruning of\n  * functions that are not needed when a limited number of SHA families are\n  * selected\n  *\n  * @define {number} ORed value of SHA variants to be supported\n  *   1 = SHA-1, 2 = SHA-224/SHA-256, 4 = SHA-384/SHA-512, 8 = SHA3\n  */\nvar SUPPORTED_ALGS = 8 | 4 | 2 | 1;\n\n(function (global)\n{\n\t\"use strict\";\n\n\t/* Globals */\n\tvar TWO_PWR_32 = 4294967296;\n\n\t/**\n\t * Int_64 is a object for 2 32-bit numbers emulating a 64-bit number\n\t *\n\t * @private\n\t * @constructor\n\t * @this {Int_64}\n\t * @param {number} msint_32 The most significant 32-bits of a 64-bit number\n\t * @param {number} lsint_32 The least significant 32-bits of a 64-bit number\n\t */\n\tfunction Int_64(msint_32, lsint_32)\n\t{\n\t\tthis.highOrder = msint_32;\n\t\tthis.lowOrder = lsint_32;\n\t}\n\n\t/**\n\t * Convert a string to an array of big-endian words\n\t *\n\t * There is a known bug with an odd number of existing bytes and using a\n\t * UTF-16 encoding.  However, this function is used such that the existing\n\t * bytes are always a result of a previous UTF-16 str2packed call and\n\t * therefore there should never be an odd number of existing bytes\n\t *\n\t * @private\n\t * @param {string} str String to be converted to binary representation\n\t * @param {string} utfType The Unicode type, UTF8 or UTF16BE, UTF16LE, to\n\t *   use to encode the source string\n\t * @param {Array<number>} existingPacked A packed int array of bytes to\n\t *   append the results to\n\t * @param {number} existingPackedLen The number of bits in the existingPacked\n\t *   array\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t *   length of \"value\"\n\t */\n\tfunction str2packed(str, utfType, existingPacked, existingPackedLen, bigEndianMod)\n\t{\n\t\tvar packed, codePnt, codePntArr, byteCnt = 0, i, j, existingByteLen,\n\t\t\tintOffset, byteOffset, shiftModifier, transposeBytes;\n\n\t\tpacked = existingPacked || [0];\n\t\texistingPackedLen = existingPackedLen || 0;\n\t\texistingByteLen = existingPackedLen >>> 3;\n\n\t\tif (\"UTF8\" === utfType)\n\t\t{\n\t\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\t\t\tfor (i = 0; i < str.length; i += 1)\n\t\t\t{\n\t\t\t\tcodePnt = str.charCodeAt(i);\n\t\t\t\tcodePntArr = [];\n\n\t\t\t\tif (0x80 > codePnt)\n\t\t\t\t{\n\t\t\t\t\tcodePntArr.push(codePnt);\n\t\t\t\t}\n\t\t\t\telse if (0x800 > codePnt)\n\t\t\t\t{\n\t\t\t\t\tcodePntArr.push(0xC0 | (codePnt >>> 6));\n\t\t\t\t\tcodePntArr.push(0x80 | (codePnt & 0x3F));\n\t\t\t\t}\n\t\t\t\telse if ((0xd800 > codePnt) || (0xe000 <= codePnt)) {\n\t\t\t\t\tcodePntArr.push(\n\t\t\t\t\t\t0xe0 | (codePnt >>> 12),\n\t\t\t\t\t\t0x80 | ((codePnt >>> 6) & 0x3f),\n\t\t\t\t\t\t0x80 | (codePnt & 0x3f)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ti += 1;\n\t\t\t\t\tcodePnt = 0x10000 + (((codePnt & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n\t\t\t\t\tcodePntArr.push(\n\t\t\t\t\t\t0xf0 | (codePnt >>> 18),\n\t\t\t\t\t\t0x80 | ((codePnt >>> 12) & 0x3f),\n\t\t\t\t\t\t0x80 | ((codePnt >>> 6) & 0x3f),\n\t\t\t\t\t\t0x80 | (codePnt & 0x3f)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tfor (j = 0; j < codePntArr.length; j += 1)\n\t\t\t\t{\n\t\t\t\t\tbyteOffset = byteCnt + existingByteLen;\n\t\t\t\t\tintOffset = byteOffset >>> 2;\n\t\t\t\t\twhile (packed.length <= intOffset)\n\t\t\t\t\t{\n\t\t\t\t\t\tpacked.push(0);\n\t\t\t\t\t}\n\t\t\t\t\t/* Known bug kicks in here */\n\t\t\t\t\tpacked[intOffset] |= codePntArr[j] << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n\t\t\t\t\tbyteCnt += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((\"UTF16BE\" === utfType) || \"UTF16LE\" === utfType)\n\t\t{\n\t\t\tshiftModifier = (bigEndianMod === -1) ? 2 : 0;\n\t\t\t/* Internally strings are UTF-16BE so transpose bytes under two conditions:\n\t\t\t\t* need LE and not switching endianness due to SHA-3\n\t\t\t\t* need BE and switching endianness due to SHA-3 */\n\t\t\ttransposeBytes = ((\"UTF16LE\" === utfType) && (bigEndianMod !== 1)) || ((\"UTF16LE\" !== utfType) && (bigEndianMod === 1));\n\t\t\tfor (i = 0; i < str.length; i += 1)\n\t\t\t{\n\t\t\t\tcodePnt = str.charCodeAt(i);\n\t\t\t\tif (transposeBytes === true)\n\t\t\t\t{\n\t\t\t\t\tj = codePnt & 0xFF;\n\t\t\t\t\tcodePnt = (j << 8) | (codePnt >>> 8);\n\t\t\t\t}\n\n\t\t\t\tbyteOffset = byteCnt + existingByteLen;\n\t\t\t\tintOffset = byteOffset >>> 2;\n\t\t\t\twhile (packed.length <= intOffset)\n\t\t\t\t{\n\t\t\t\t\tpacked.push(0);\n\t\t\t\t}\n\t\t\t\tpacked[intOffset] |= codePnt << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n\t\t\t\tbyteCnt += 2;\n\t\t\t}\n\t\t}\n\t\treturn {\"value\" : packed, \"binLen\" : byteCnt * 8 + existingPackedLen};\n\t}\n\n\t/**\n\t * Convert a hex string to an array of big-endian words\n\t *\n\t * @private\n\t * @param {string} str String to be converted to binary representation\n\t * @param {Array<number>} existingPacked A packed int array of bytes to\n\t *   append the results to\n\t * @param {number} existingPackedLen The number of bits in the existingPacked\n\t *   array\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t *   length of \"value\"\n\t */\n\tfunction hex2packed(str, existingPacked, existingPackedLen, bigEndianMod)\n\t{\n\t\tvar packed, length = str.length, i, num, intOffset, byteOffset,\n\t\t\texistingByteLen, shiftModifier;\n\n\t\tif (0 !== (length % 2))\n\t\t{\n\t\t\tthrow new Error(\"String of HEX type must be in byte increments\");\n\t\t}\n\n\t\tpacked = existingPacked || [0];\n\t\texistingPackedLen = existingPackedLen || 0;\n\t\texistingByteLen = existingPackedLen >>> 3;\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n\t\tfor (i = 0; i < length; i += 2)\n\t\t{\n\t\t\tnum = parseInt(str.substr(i, 2), 16);\n\t\t\tif (!isNaN(num))\n\t\t\t{\n\t\t\t\tbyteOffset = (i >>> 1) + existingByteLen;\n\t\t\t\tintOffset = byteOffset >>> 2;\n\t\t\t\twhile (packed.length <= intOffset)\n\t\t\t\t{\n\t\t\t\t\tpacked.push(0);\n\t\t\t\t}\n\t\t\t\tpacked[intOffset] |= num  << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new Error(\"String of HEX type contains invalid characters\");\n\t\t\t}\n\t\t}\n\n\t\treturn {\"value\" : packed, \"binLen\" : length * 4 + existingPackedLen};\n\t}\n\n\t/**\n\t * Convert a string of raw bytes to an array of big-endian words\n\t *\n\t * @private\n\t * @param {string} str String of raw bytes to be converted to binary representation\n\t * @param {Array<number>} existingPacked A packed int array of bytes to\n\t *   append the results to\n\t * @param {number} existingPackedLen The number of bits in the existingPacked\n\t *   array\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t *   length of \"value\"\n\t */\n\tfunction bytes2packed(str, existingPacked, existingPackedLen, bigEndianMod)\n\t{\n\t\tvar packed, codePnt, i, existingByteLen, intOffset,\n\t\t\tbyteOffset, shiftModifier;\n\n\t\tpacked = existingPacked || [0];\n\t\texistingPackedLen = existingPackedLen || 0;\n\t\texistingByteLen = existingPackedLen >>> 3;\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n\t\tfor (i = 0; i < str.length; i += 1)\n\t\t{\n\t\t\tcodePnt = str.charCodeAt(i);\n\n\t\t\tbyteOffset = i + existingByteLen;\n\t\t\tintOffset = byteOffset >>> 2;\n\t\t\tif (packed.length <= intOffset)\n\t\t\t{\n\t\t\t\tpacked.push(0);\n\t\t\t}\n\t\t\tpacked[intOffset] |= codePnt << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n\t\t}\n\n\t\treturn {\"value\" : packed, \"binLen\" : str.length * 8 + existingPackedLen};\n\t}\n\n\t/**\n\t * Convert a base-64 string to an array of big-endian words\n\t *\n\t * @private\n\t * @param {string} str String to be converted to binary representation\n\t * @param {Array<number>} existingPacked A packed int array of bytes to\n\t *   append the results to\n\t * @param {number} existingPackedLen The number of bits in the existingPacked\n\t *   array\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t *   length of \"value\"\n\t */\n\tfunction b642packed(str, existingPacked, existingPackedLen, bigEndianMod)\n\t{\n\t\tvar packed, byteCnt = 0, index, i, j, tmpInt, strPart, firstEqual,\n\t\t\tb64Tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n\t\t\texistingByteLen, intOffset, byteOffset, shiftModifier;\n\n\t\tif (-1 === str.search(/^[a-zA-Z0-9=+\\/]+$/))\n\t\t{\n\t\t\tthrow new Error(\"Invalid character in base-64 string\");\n\t\t}\n\n\t\tfirstEqual = str.indexOf(\"=\");\n\t\tstr = str.replace(/\\=/g, \"\");\n\t\tif ((-1 !== firstEqual) && (firstEqual < str.length))\n\t\t{\n\t\t\tthrow new Error(\"Invalid '=' found in base-64 string\");\n\t\t}\n\n\t\tpacked = existingPacked || [0];\n\t\texistingPackedLen = existingPackedLen || 0;\n\t\texistingByteLen = existingPackedLen >>> 3;\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n\t\tfor (i = 0; i < str.length; i += 4)\n\t\t{\n\t\t\tstrPart = str.substr(i, 4);\n\t\t\ttmpInt = 0;\n\n\t\t\tfor (j = 0; j < strPart.length; j += 1)\n\t\t\t{\n\t\t\t\tindex = b64Tab.indexOf(strPart[j]);\n\t\t\t\ttmpInt |= index << (18 - (6 * j));\n\t\t\t}\n\n\t\t\tfor (j = 0; j < strPart.length - 1; j += 1)\n\t\t\t{\n\t\t\t\tbyteOffset = byteCnt + existingByteLen;\n\t\t\t\tintOffset = byteOffset >>> 2;\n\t\t\t\twhile (packed.length <= intOffset)\n\t\t\t\t{\n\t\t\t\t\tpacked.push(0);\n\t\t\t\t}\n\t\t\t\tpacked[intOffset] |= ((tmpInt >>> (16 - (j * 8))) & 0xFF) <<\n\t\t\t\t\t(8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n\t\t\t\tbyteCnt += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn {\"value\" : packed, \"binLen\" : byteCnt * 8 + existingPackedLen};\n\t}\n\n\t/**\n\t * Convert an ArrayBuffer to an array of big-endian words\n\t *\n\t * @private\n\t * @param {ArrayBuffer} arr ArrayBuffer to be converted to binary\n\t *   representation\n\t * @param {Array<number>} existingPacked A packed int array of bytes to\n\t *   append the results to\n\t * @param {number} existingPackedLen The number of bits in the existingPacked\n\t *   array\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t *   length of \"value\"\n\t */\n\tfunction arraybuffer2packed(arr, existingPacked, existingPackedLen, bigEndianMod)\n\t{\n\t\tvar packed, i, existingByteLen, intOffset, byteOffset, shiftModifier, arrView;\n\n\t\tpacked = existingPacked || [0];\n\t\texistingPackedLen = existingPackedLen || 0;\n\t\texistingByteLen = existingPackedLen >>> 3;\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\t\tarrView = new Uint8Array(arr);\n\n\t\tfor (i = 0; i < arr.byteLength; i += 1)\n\t\t{\n\t\t\tbyteOffset = i + existingByteLen;\n\t\t\tintOffset = byteOffset >>> 2;\n\t\t\tif (packed.length <= intOffset)\n\t\t\t{\n\t\t\t\tpacked.push(0);\n\t\t\t}\n\t\t\tpacked[intOffset] |= arrView[i] << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n\t\t}\n\n\t\treturn {\"value\" : packed, \"binLen\" : arr.byteLength * 8 + existingPackedLen};\n\t}\n\n\t/**\n\t * Convert an array of big-endian words to a hex string.\n\t *\n\t * @private\n\t * @param {Array<number>} packed Array of integers to be converted to\n\t *   hexidecimal representation\n\t * @param {number} outputLength Length of output in bits\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @param {{outputUpper : boolean, b64Pad : string}} formatOpts Hash list\n\t *   containing validated output formatting options\n\t * @return {string} Hexidecimal representation of the parameter in string\n\t *   form\n\t */\n\tfunction packed2hex(packed, outputLength, bigEndianMod, formatOpts)\n\t{\n\t\tvar hex_tab = \"0123456789abcdef\", str = \"\",\n\t\t\tlength = outputLength / 8, i, srcByte, shiftModifier;\n\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n\t\tfor (i = 0; i < length; i += 1)\n\t\t{\n\t\t\t/* The below is more than a byte but it gets taken care of later */\n\t\t\tsrcByte = packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)));\n\t\t\tstr += hex_tab.charAt((srcByte >>> 4) & 0xF) +\n\t\t\t\thex_tab.charAt(srcByte & 0xF);\n\t\t}\n\n\t\treturn (formatOpts[\"outputUpper\"]) ? str.toUpperCase() : str;\n\t}\n\n\t/**\n\t * Convert an array of big-endian words to a base-64 string\n\t *\n\t * @private\n\t * @param {Array<number>} packed Array of integers to be converted to\n\t *   base-64 representation\n\t * @param {number} outputLength Length of output in bits\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @param {{outputUpper : boolean, b64Pad : string}} formatOpts Hash list\n\t *   containing validated output formatting options\n\t * @return {string} Base-64 encoded representation of the parameter in\n\t *   string form\n\t */\n\tfunction packed2b64(packed, outputLength, bigEndianMod, formatOpts)\n\t{\n\t\tvar str = \"\", length = outputLength / 8, i, j, triplet, int1, int2, shiftModifier,\n\t\t\tb64Tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n\t\tfor (i = 0; i < length; i += 3)\n\t\t{\n\t\t\tint1 = ((i + 1) < length) ? packed[(i + 1) >>> 2] : 0;\n\t\t\tint2 = ((i + 2) < length) ? packed[(i + 2) >>> 2] : 0;\n\t\t\ttriplet = (((packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)))) & 0xFF) << 16) |\n\t\t\t\t(((int1 >>> (8 * (shiftModifier + bigEndianMod * ((i + 1) % 4)))) & 0xFF) << 8) |\n\t\t\t\t((int2 >>> (8 * (shiftModifier + bigEndianMod * ((i + 2) % 4)))) & 0xFF);\n\t\t\tfor (j = 0; j < 4; j += 1)\n\t\t\t{\n\t\t\t\tif (i * 8 + j * 6 <= outputLength)\n\t\t\t\t{\n\t\t\t\t\tstr += b64Tab.charAt((triplet >>> 6 * (3 - j)) & 0x3F);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstr += formatOpts[\"b64Pad\"];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn str;\n\t}\n\n\t/**\n\t * Convert an array of big-endian words to raw bytes string\n\t *\n\t * @private\n\t * @param {Array<number>} packed Array of integers to be converted to\n\t *   a raw bytes string representation\n\t * @param {number} outputLength Length of output in bits\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {string} Raw bytes representation of the parameter in string\n\t *   form\n\t */\n\tfunction packed2bytes(packed, outputLength, bigEndianMod)\n\t{\n\t\tvar str = \"\", length = outputLength / 8, i, srcByte, shiftModifier;\n\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n\t\tfor (i = 0; i < length; i += 1)\n\t\t{\n\t\t\tsrcByte = (packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)))) & 0xFF;\n\t\t\tstr += String.fromCharCode(srcByte);\n\t\t}\n\n\t\treturn str;\n\t}\n\n\t/**\n\t * Convert an array of big-endian words to an ArrayBuffer\n\t *\n\t * @private\n\t * @param {Array<number>} packed Array of integers to be converted to\n\t *   an ArrayBuffer\n\t * @param {number} outputLength Length of output in bits\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {ArrayBuffer} Raw bytes representation of the parameter in an\n\t *   ArrayBuffer\n\t */\n\tfunction packed2arraybuffer(packed, outputLength, bigEndianMod)\n\t{\n\t\tvar length = outputLength / 8, i, retVal = new ArrayBuffer(length), shiftModifier, arrView;\n\t\tarrView = new Uint8Array(retVal);\n\n\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n\t\tfor (i = 0; i < length; i += 1)\n\t\t{\n\t\t\tarrView[i] = (packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)))) & 0xFF;\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * Validate hash list containing output formatting options, ensuring\n\t * presence of every option or adding the default value\n\t *\n\t * @private\n\t * @param {{outputUpper : (boolean|undefined), b64Pad : (string|undefined),\n\t *   shakeLen : (number|undefined)}=} options Hash list of output formatting options\n\t * @return {{outputUpper : boolean, b64Pad : string, shakeLen : number}} Validated\n\t *   hash list containing output formatting options\n\t */\n\tfunction getOutputOpts(options)\n\t{\n\t\tvar retVal = {\"outputUpper\" : false, \"b64Pad\" : \"=\", \"shakeLen\" : -1},\n\t\t\toutputOptions;\n\t\toutputOptions = options || {};\n\n\t\tretVal[\"outputUpper\"] = outputOptions[\"outputUpper\"] || false;\n\n\t\tif (true === outputOptions.hasOwnProperty(\"b64Pad\"))\n\t\t{\n\t\t\tretVal[\"b64Pad\"] = outputOptions[\"b64Pad\"];\n\t\t}\n\n\t\tif ((true === outputOptions.hasOwnProperty(\"shakeLen\")) && ((8 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tif (outputOptions[\"shakeLen\"] % 8 !== 0)\n\t\t\t{\n\t\t\t\tthrow new Error(\"shakeLen must be a multiple of 8\");\n\t\t\t}\n\t\t\tretVal[\"shakeLen\"] = outputOptions[\"shakeLen\"];\n\t\t}\n\n\t\tif (\"boolean\" !== typeof(retVal[\"outputUpper\"]))\n\t\t{\n\t\t\tthrow new Error(\"Invalid outputUpper formatting option\");\n\t\t}\n\n\t\tif (\"string\" !== typeof(retVal[\"b64Pad\"]))\n\t\t{\n\t\t\tthrow new Error(\"Invalid b64Pad formatting option\");\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * Function that takes an input format and UTF encoding and returns the\n\t * appropriate function used to convert the input.\n\t *\n\t * @private\n\t * @param {string} format The format of the string to be converted\n\t * @param {string} utfType The string encoding to use (UTF8, UTF16BE,\n\t *\tUTF16LE)\n\t * @param {number} bigEndianMod Modifier for whether hash function is\n\t *   big or small endian\n\t * @return {function((string|ArrayBuffer), Array<number>=, number=): {value :\n\t *   Array<number>, binLen : number}} Function that will convert an input\n\t *   string to a packed int array\n\t */\n\tfunction getStrConverter(format, utfType, bigEndianMod)\n\t{\n\t\tvar retVal;\n\n\t\t/* Validate encoding */\n\t\tswitch (utfType)\n\t\t{\n\t\tcase \"UTF8\":\n\t\t\t/* Fallthrough */\n\t\tcase \"UTF16BE\":\n\t\t\t/* Fallthrough */\n\t\tcase \"UTF16LE\":\n\t\t\t/* Fallthrough */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error(\"encoding must be UTF8, UTF16BE, or UTF16LE\");\n\t\t}\n\n\t\t/* Map inputFormat to the appropriate converter */\n\t\tswitch (format)\n\t\t{\n\t\tcase \"HEX\":\n\t\t\t/**\n\t\t\t * @param {string} str String of raw bytes to be converted to binary representation\n\t\t\t * @param {Array<number>} existingBin A packed int array of bytes to\n\t\t\t *   append the results to\n\t\t\t * @param {number} existingBinLen The number of bits in the existingBin\n\t\t\t *   array\n\t\t\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t\t\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t\t\t *   length of \"value\"\n\t\t\t */\n\t\t\tretVal = function(str, existingBin, existingBinLen)\n\t\t\t\t{\n\t\t\t\t   return hex2packed(str, existingBin, existingBinLen, bigEndianMod);\n\t\t\t\t};\n\t\t\tbreak;\n\t\tcase \"TEXT\":\n\t\t\t/**\n\t\t\t * @param {string} str String of raw bytes to be converted to binary representation\n\t\t\t * @param {Array<number>} existingBin A packed int array of bytes to\n\t\t\t *   append the results to\n\t\t\t * @param {number} existingBinLen The number of bits in the existingBin\n\t\t\t *   array\n\t\t\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t\t\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t\t\t *   length of \"value\"\n\t\t\t */\n\t\t\tretVal = function(str, existingBin, existingBinLen)\n\t\t\t\t{\n\t\t\t\t\treturn str2packed(str, utfType, existingBin, existingBinLen, bigEndianMod);\n\t\t\t\t};\n\t\t\tbreak;\n\t\tcase \"B64\":\n\t\t\t/**\n\t\t\t * @param {string} str String of raw bytes to be converted to binary representation\n\t\t\t * @param {Array<number>} existingBin A packed int array of bytes to\n\t\t\t *   append the results to\n\t\t\t * @param {number} existingBinLen The number of bits in the existingBin\n\t\t\t *   array\n\t\t\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t\t\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t\t\t *   length of \"value\"\n\t\t\t */\n\t\t\tretVal = function(str, existingBin, existingBinLen)\n\t\t\t\t{\n\t\t\t\t   return b642packed(str, existingBin, existingBinLen, bigEndianMod);\n\t\t\t\t};\n\t\t\tbreak;\n\t\tcase \"BYTES\":\n\t\t\t/**\n\t\t\t * @param {string} str String of raw bytes to be converted to binary representation\n\t\t\t * @param {Array<number>} existingBin A packed int array of bytes to\n\t\t\t *   append the results to\n\t\t\t * @param {number} existingBinLen The number of bits in the existingBin\n\t\t\t *   array\n\t\t\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t\t\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t\t\t *   length of \"value\"\n\t\t\t */\n\t\t\tretVal = function(str, existingBin, existingBinLen)\n\t\t\t\t{\n\t\t\t\t   return bytes2packed(str, existingBin, existingBinLen, bigEndianMod);\n\t\t\t\t};\n\t\t\tbreak;\n\t\tcase \"ARRAYBUFFER\":\n\t\t\ttry {\n\t\t\t\tretVal = new ArrayBuffer(0);\n\t\t\t} catch(ignore) {\n\t\t\t\tthrow new Error(\"ARRAYBUFFER not supported by this environment\");\n\t\t\t}\n\t\t\t/**\n\t\t\t * @param {ArrayBuffer} arr ArrayBuffer to be converted to binary\n\t\t\t *   representation\n\t\t\t * @param {Array<number>} existingBin A packed int array of bytes to\n\t\t\t *   append the results to\n\t\t\t * @param {number} existingBinLen The number of bits in the existingBin\n\t\t\t *   array\n\t\t\t * @return {{value : Array<number>, binLen : number}} Hash list where\n\t\t\t *   \"value\" contains the output number array and \"binLen\" is the binary\n\t\t\t *   length of \"value\"\n\t\t\t */\n\t\t\tretVal = function(arr, existingBin, existingBinLen)\n\t\t\t\t{\n\t\t\t\t   return arraybuffer2packed(arr, existingBin, existingBinLen, bigEndianMod);\n\t\t\t\t};\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error(\"format must be HEX, TEXT, B64, BYTES, or ARRAYBUFFER\");\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * The 32-bit implementation of circular rotate left\n\t *\n\t * @private\n\t * @param {number} x The 32-bit integer argument\n\t * @param {number} n The number of bits to shift\n\t * @return {number} The x shifted circularly by n bits\n\t */\n\tfunction rotl_32(x, n)\n\t{\n\t\treturn (x << n) | (x >>> (32 - n));\n\t}\n\n\t/**\n\t * The 64-bit implementation of circular rotate left\n\t *\n\t * @private\n\t * @param {Int_64} x The 64-bit integer argument\n\t * @param {number} n The number of bits to shift\n\t * @return {Int_64} The x shifted circularly by n bits\n\t */\n\tfunction rotl_64(x, n)\n\t{\n\t\tif (n > 32)\n\t\t{\n\t\t\tn = n - 32;\n\t\t\treturn new Int_64(\n\t\t\t\tx.lowOrder << n | x.highOrder >>> (32 - n),\n\t\t\t\tx.highOrder << n | x.lowOrder >>> (32 - n)\n\t\t\t);\n\t\t}\n\t\telse if (0 !== n)\n\t\t{\n\t\t\treturn new Int_64(\n\t\t\t\tx.highOrder << n | x.lowOrder >>> (32 - n),\n\t\t\t\tx.lowOrder << n | x.highOrder >>> (32 - n)\n\t\t\t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t}\n\n\t/**\n\t * The 32-bit implementation of circular rotate right\n\t *\n\t * @private\n\t * @param {number} x The 32-bit integer argument\n\t * @param {number} n The number of bits to shift\n\t * @return {number} The x shifted circularly by n bits\n\t */\n\tfunction rotr_32(x, n)\n\t{\n\t\treturn (x >>> n) | (x << (32 - n));\n\t}\n\n\t/**\n\t * The 64-bit implementation of circular rotate right\n\t *\n\t * @private\n\t * @param {Int_64} x The 64-bit integer argument\n\t * @param {number} n The number of bits to shift\n\t * @return {Int_64} The x shifted circularly by n bits\n\t */\n\tfunction rotr_64(x, n)\n\t{\n\t\tvar retVal = null, tmp = new Int_64(x.highOrder, x.lowOrder);\n\n\t\tif (32 >= n)\n\t\t{\n\t\t\tretVal = new Int_64(\n\t\t\t\t\t(tmp.highOrder >>> n) | ((tmp.lowOrder << (32 - n)) & 0xFFFFFFFF),\n\t\t\t\t\t(tmp.lowOrder >>> n) | ((tmp.highOrder << (32 - n)) & 0xFFFFFFFF)\n\t\t\t\t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tretVal = new Int_64(\n\t\t\t\t\t(tmp.lowOrder >>> (n - 32)) | ((tmp.highOrder << (64 - n)) & 0xFFFFFFFF),\n\t\t\t\t\t(tmp.highOrder >>> (n - 32)) | ((tmp.lowOrder << (64 - n)) & 0xFFFFFFFF)\n\t\t\t\t);\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * The 32-bit implementation of shift right\n\t *\n\t * @private\n\t * @param {number} x The 32-bit integer argument\n\t * @param {number} n The number of bits to shift\n\t * @return {number} The x shifted by n bits\n\t */\n\tfunction shr_32(x, n)\n\t{\n\t\treturn x >>> n;\n\t}\n\n\t/**\n\t * The 64-bit implementation of shift right\n\t *\n\t * @private\n\t * @param {Int_64} x The 64-bit integer argument\n\t * @param {number} n The number of bits to shift\n\t * @return {Int_64} The x shifted by n bits\n\t */\n\tfunction shr_64(x, n)\n\t{\n\t\tvar retVal = null;\n\n\t\tif (32 >= n)\n\t\t{\n\t\t\tretVal = new Int_64(\n\t\t\t\t\tx.highOrder >>> n,\n\t\t\t\t\tx.lowOrder >>> n | ((x.highOrder << (32 - n)) & 0xFFFFFFFF)\n\t\t\t\t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tretVal = new Int_64(\n\t\t\t\t\t0,\n\t\t\t\t\tx.highOrder >>> (n - 32)\n\t\t\t\t);\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * The 32-bit implementation of the NIST specified Parity function\n\t *\n\t * @private\n\t * @param {number} x The first 32-bit integer argument\n\t * @param {number} y The second 32-bit integer argument\n\t * @param {number} z The third 32-bit integer argument\n\t * @return {number} The NIST specified output of the function\n\t */\n\tfunction parity_32(x, y, z)\n\t{\n\t\treturn x ^ y ^ z;\n\t}\n\n\t/**\n\t * The 32-bit implementation of the NIST specified Ch function\n\t *\n\t * @private\n\t * @param {number} x The first 32-bit integer argument\n\t * @param {number} y The second 32-bit integer argument\n\t * @param {number} z The third 32-bit integer argument\n\t * @return {number} The NIST specified output of the function\n\t */\n\tfunction ch_32(x, y, z)\n\t{\n\t\treturn (x & y) ^ (~x & z);\n\t}\n\n\t/**\n\t * The 64-bit implementation of the NIST specified Ch function\n\t *\n\t * @private\n\t * @param {Int_64} x The first 64-bit integer argument\n\t * @param {Int_64} y The second 64-bit integer argument\n\t * @param {Int_64} z The third 64-bit integer argument\n\t * @return {Int_64} The NIST specified output of the function\n\t */\n\tfunction ch_64(x, y, z)\n\t{\n\t\treturn new Int_64(\n\t\t\t\t(x.highOrder & y.highOrder) ^ (~x.highOrder & z.highOrder),\n\t\t\t\t(x.lowOrder & y.lowOrder) ^ (~x.lowOrder & z.lowOrder)\n\t\t\t);\n\t}\n\n\t/**\n\t * The 32-bit implementation of the NIST specified Maj function\n\t *\n\t * @private\n\t * @param {number} x The first 32-bit integer argument\n\t * @param {number} y The second 32-bit integer argument\n\t * @param {number} z The third 32-bit integer argument\n\t * @return {number} The NIST specified output of the function\n\t */\n\tfunction maj_32(x, y, z)\n\t{\n\t\treturn (x & y) ^ (x & z) ^ (y & z);\n\t}\n\n\t/**\n\t * The 64-bit implementation of the NIST specified Maj function\n\t *\n\t * @private\n\t * @param {Int_64} x The first 64-bit integer argument\n\t * @param {Int_64} y The second 64-bit integer argument\n\t * @param {Int_64} z The third 64-bit integer argument\n\t * @return {Int_64} The NIST specified output of the function\n\t */\n\tfunction maj_64(x, y, z)\n\t{\n\t\treturn new Int_64(\n\t\t\t\t(x.highOrder & y.highOrder) ^\n\t\t\t\t(x.highOrder & z.highOrder) ^\n\t\t\t\t(y.highOrder & z.highOrder),\n\t\t\t\t(x.lowOrder & y.lowOrder) ^\n\t\t\t\t(x.lowOrder & z.lowOrder) ^\n\t\t\t\t(y.lowOrder & z.lowOrder)\n\t\t\t);\n\t}\n\n\t/**\n\t * The 32-bit implementation of the NIST specified Sigma0 function\n\t *\n\t * @private\n\t * @param {number} x The 32-bit integer argument\n\t * @return {number} The NIST specified output of the function\n\t */\n\tfunction sigma0_32(x)\n\t{\n\t\treturn rotr_32(x, 2) ^ rotr_32(x, 13) ^ rotr_32(x, 22);\n\t}\n\n\t/**\n\t * The 64-bit implementation of the NIST specified Sigma0 function\n\t *\n\t * @private\n\t * @param {Int_64} x The 64-bit integer argument\n\t * @return {Int_64} The NIST specified output of the function\n\t */\n\tfunction sigma0_64(x)\n\t{\n\t\tvar rotr28 = rotr_64(x, 28), rotr34 = rotr_64(x, 34),\n\t\t\trotr39 = rotr_64(x, 39);\n\n\t\treturn new Int_64(\n\t\t\t\trotr28.highOrder ^ rotr34.highOrder ^ rotr39.highOrder,\n\t\t\t\trotr28.lowOrder ^ rotr34.lowOrder ^ rotr39.lowOrder);\n\t}\n\n\t/**\n\t * The 32-bit implementation of the NIST specified Sigma1 function\n\t *\n\t * @private\n\t * @param {number} x The 32-bit integer argument\n\t * @return {number} The NIST specified output of the function\n\t */\n\tfunction sigma1_32(x)\n\t{\n\t\treturn rotr_32(x, 6) ^ rotr_32(x, 11) ^ rotr_32(x, 25);\n\t}\n\n\t/**\n\t * The 64-bit implementation of the NIST specified Sigma1 function\n\t *\n\t * @private\n\t * @param {Int_64} x The 64-bit integer argument\n\t * @return {Int_64} The NIST specified output of the function\n\t */\n\tfunction sigma1_64(x)\n\t{\n\t\tvar rotr14 = rotr_64(x, 14), rotr18 = rotr_64(x, 18),\n\t\t\trotr41 = rotr_64(x, 41);\n\n\t\treturn new Int_64(\n\t\t\t\trotr14.highOrder ^ rotr18.highOrder ^ rotr41.highOrder,\n\t\t\t\trotr14.lowOrder ^ rotr18.lowOrder ^ rotr41.lowOrder);\n\t}\n\n\t/**\n\t * The 32-bit implementation of the NIST specified Gamma0 function\n\t *\n\t * @private\n\t * @param {number} x The 32-bit integer argument\n\t * @return {number} The NIST specified output of the function\n\t */\n\tfunction gamma0_32(x)\n\t{\n\t\treturn rotr_32(x, 7) ^ rotr_32(x, 18) ^ shr_32(x, 3);\n\t}\n\n\t/**\n\t * The 64-bit implementation of the NIST specified Gamma0 function\n\t *\n\t * @private\n\t * @param {Int_64} x The 64-bit integer argument\n\t * @return {Int_64} The NIST specified output of the function\n\t */\n\tfunction gamma0_64(x)\n\t{\n\t\tvar rotr1 = rotr_64(x, 1), rotr8 = rotr_64(x, 8), shr7 = shr_64(x, 7);\n\n\t\treturn new Int_64(\n\t\t\t\trotr1.highOrder ^ rotr8.highOrder ^ shr7.highOrder,\n\t\t\t\trotr1.lowOrder ^ rotr8.lowOrder ^ shr7.lowOrder\n\t\t\t);\n\t}\n\n\t/**\n\t * The 32-bit implementation of the NIST specified Gamma1 function\n\t *\n\t * @private\n\t * @param {number} x The 32-bit integer argument\n\t * @return {number} The NIST specified output of the function\n\t */\n\tfunction gamma1_32(x)\n\t{\n\t\treturn rotr_32(x, 17) ^ rotr_32(x, 19) ^ shr_32(x, 10);\n\t}\n\n\t/**\n\t * The 64-bit implementation of the NIST specified Gamma1 function\n\t *\n\t * @private\n\t * @param {Int_64} x The 64-bit integer argument\n\t * @return {Int_64} The NIST specified output of the function\n\t */\n\tfunction gamma1_64(x)\n\t{\n\t\tvar rotr19 = rotr_64(x, 19), rotr61 = rotr_64(x, 61),\n\t\t\tshr6 = shr_64(x, 6);\n\n\t\treturn new Int_64(\n\t\t\t\trotr19.highOrder ^ rotr61.highOrder ^ shr6.highOrder,\n\t\t\t\trotr19.lowOrder ^ rotr61.lowOrder ^ shr6.lowOrder\n\t\t\t);\n\t}\n\n\t/**\n\t * Add two 32-bit integers, wrapping at 2^32. This uses 16-bit operations\n\t * internally to work around bugs in some JS interpreters.\n\t *\n\t * @private\n\t * @param {number} a The first 32-bit integer argument to be added\n\t * @param {number} b The second 32-bit integer argument to be added\n\t * @return {number} The sum of a + b\n\t */\n\tfunction safeAdd_32_2(a, b)\n\t{\n\t\tvar lsw = (a & 0xFFFF) + (b & 0xFFFF),\n\t\t\tmsw = (a >>> 16) + (b >>> 16) + (lsw >>> 16);\n\n\t\treturn ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\t}\n\n\t/**\n\t * Add four 32-bit integers, wrapping at 2^32. This uses 16-bit operations\n\t * internally to work around bugs in some JS interpreters.\n\t *\n\t * @private\n\t * @param {number} a The first 32-bit integer argument to be added\n\t * @param {number} b The second 32-bit integer argument to be added\n\t * @param {number} c The third 32-bit integer argument to be added\n\t * @param {number} d The fourth 32-bit integer argument to be added\n\t * @return {number} The sum of a + b + c + d\n\t */\n\tfunction safeAdd_32_4(a, b, c, d)\n\t{\n\t\tvar lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF),\n\t\t\tmsw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) +\n\t\t\t\t(lsw >>> 16);\n\n\t\treturn ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\t}\n\n\t/**\n\t * Add five 32-bit integers, wrapping at 2^32. This uses 16-bit operations\n\t * internally to work around bugs in some JS interpreters.\n\t *\n\t * @private\n\t * @param {number} a The first 32-bit integer argument to be added\n\t * @param {number} b The second 32-bit integer argument to be added\n\t * @param {number} c The third 32-bit integer argument to be added\n\t * @param {number} d The fourth 32-bit integer argument to be added\n\t * @param {number} e The fifth 32-bit integer argument to be added\n\t * @return {number} The sum of a + b + c + d + e\n\t */\n\tfunction safeAdd_32_5(a, b, c, d, e)\n\t{\n\t\tvar lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF) +\n\t\t\t\t(e & 0xFFFF),\n\t\t\tmsw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) +\n\t\t\t\t(e >>> 16) + (lsw >>> 16);\n\n\t\treturn ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\t}\n\n\t/**\n\t * Add two 64-bit integers, wrapping at 2^64. This uses 16-bit operations\n\t * internally to work around bugs in some JS interpreters.\n\t *\n\t * @private\n\t * @param {Int_64} x The first 64-bit integer argument to be added\n\t * @param {Int_64} y The second 64-bit integer argument to be added\n\t * @return {Int_64} The sum of x + y\n\t */\n\tfunction safeAdd_64_2(x, y)\n\t{\n\t\tvar lsw, msw, lowOrder, highOrder;\n\n\t\tlsw = (x.lowOrder & 0xFFFF) + (y.lowOrder & 0xFFFF);\n\t\tmsw = (x.lowOrder >>> 16) + (y.lowOrder >>> 16) + (lsw >>> 16);\n\t\tlowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n\t\tlsw = (x.highOrder & 0xFFFF) + (y.highOrder & 0xFFFF) + (msw >>> 16);\n\t\tmsw = (x.highOrder >>> 16) + (y.highOrder >>> 16) + (lsw >>> 16);\n\t\thighOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n\t\treturn new Int_64(highOrder, lowOrder);\n\t}\n\n\t/**\n\t * Add four 64-bit integers, wrapping at 2^64. This uses 16-bit operations\n\t * internally to work around bugs in some JS interpreters.\n\t *\n\t * @private\n\t * @param {Int_64} a The first 64-bit integer argument to be added\n\t * @param {Int_64} b The second 64-bit integer argument to be added\n\t * @param {Int_64} c The third 64-bit integer argument to be added\n\t * @param {Int_64} d The fouth 64-bit integer argument to be added\n\t * @return {Int_64} The sum of a + b + c + d\n\t */\n\tfunction safeAdd_64_4(a, b, c, d)\n\t{\n\t\tvar lsw, msw, lowOrder, highOrder;\n\n\t\tlsw = (a.lowOrder & 0xFFFF) + (b.lowOrder & 0xFFFF) +\n\t\t\t(c.lowOrder & 0xFFFF) + (d.lowOrder & 0xFFFF);\n\t\tmsw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) +\n\t\t\t(c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (lsw >>> 16);\n\t\tlowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n\t\tlsw = (a.highOrder & 0xFFFF) + (b.highOrder & 0xFFFF) +\n\t\t\t(c.highOrder & 0xFFFF) + (d.highOrder & 0xFFFF) + (msw >>> 16);\n\t\tmsw = (a.highOrder >>> 16) + (b.highOrder >>> 16) +\n\t\t\t(c.highOrder >>> 16) + (d.highOrder >>> 16) + (lsw >>> 16);\n\t\thighOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n\t\treturn new Int_64(highOrder, lowOrder);\n\t}\n\n\t/**\n\t * Add five 64-bit integers, wrapping at 2^64. This uses 16-bit operations\n\t * internally to work around bugs in some JS interpreters.\n\t *\n\t * @private\n\t * @param {Int_64} a The first 64-bit integer argument to be added\n\t * @param {Int_64} b The second 64-bit integer argument to be added\n\t * @param {Int_64} c The third 64-bit integer argument to be added\n\t * @param {Int_64} d The fouth 64-bit integer argument to be added\n\t * @param {Int_64} e The fouth 64-bit integer argument to be added\n\t * @return {Int_64} The sum of a + b + c + d + e\n\t */\n\tfunction safeAdd_64_5(a, b, c, d, e)\n\t{\n\t\tvar lsw, msw, lowOrder, highOrder;\n\n\t\tlsw = (a.lowOrder & 0xFFFF) + (b.lowOrder & 0xFFFF) +\n\t\t\t(c.lowOrder & 0xFFFF) + (d.lowOrder & 0xFFFF) +\n\t\t\t(e.lowOrder & 0xFFFF);\n\t\tmsw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) +\n\t\t\t(c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (e.lowOrder >>> 16) +\n\t\t\t(lsw >>> 16);\n\t\tlowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n\t\tlsw = (a.highOrder & 0xFFFF) + (b.highOrder & 0xFFFF) +\n\t\t\t(c.highOrder & 0xFFFF) + (d.highOrder & 0xFFFF) +\n\t\t\t(e.highOrder & 0xFFFF) + (msw >>> 16);\n\t\tmsw = (a.highOrder >>> 16) + (b.highOrder >>> 16) +\n\t\t\t(c.highOrder >>> 16) + (d.highOrder >>> 16) +\n\t\t\t(e.highOrder >>> 16) + (lsw >>> 16);\n\t\thighOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n\t\treturn new Int_64(highOrder, lowOrder);\n\t}\n\n\t/**\n\t * XORs two given arguments.\n\t *\n\t * @private\n\t * @param {Int_64} a First argument to be XORed\n\t * @param {Int_64} b Second argument to be XORed\n\t * @return {Int_64} The XOR of the arguments\n\t */\n\tfunction xor_64_2(a, b)\n\t{\n\t\treturn new Int_64(\n\t\t\ta.highOrder ^ b.highOrder,\n\t\t\ta.lowOrder ^ b.lowOrder\n\t\t);\n\t}\n\n\t/**\n\t * XORs five given arguments.\n\t *\n\t * @private\n\t * @param {Int_64} a First argument to be XORed\n\t * @param {Int_64} b Second argument to be XORed\n\t * @param {Int_64} c Third argument to be XORed\n\t * @param {Int_64} d Fourth argument to be XORed\n\t * @param {Int_64} e Fifth argument to be XORed\n\t * @return {Int_64} The XOR of the arguments\n\t */\n\tfunction xor_64_5(a, b, c, d, e)\n\t{\n\t\treturn new Int_64(\n\t\t\ta.highOrder ^ b.highOrder ^ c.highOrder ^ d.highOrder ^ e.highOrder,\n\t\t\ta.lowOrder ^ b.lowOrder ^ c.lowOrder ^ d.lowOrder ^ e.lowOrder\n\t\t);\n\t}\n\n\t/**\n\t * Returns a clone of the given SHA3 state\n\t *\n\t * @private\n\t * @param {Array<Array<Int_64>>} state The state to be cloned\n\t * @return {Array<Array<Int_64>>} The cloned state\n\t */\n\tfunction cloneSHA3State(state) {\n\t\tvar clone = [], i;\n\t\tfor (i = 0; i < 5; i += 1)\n\t\t{\n\t\t\tclone[i] = state[i].slice();\n\t\t}\n\n\t\treturn clone;\n\t}\n\n\t/**\n\t * Gets the state values for the specified SHA variant\n\t *\n\t * @param {string} variant The SHA variant\n\t * @return {Array<number|Int_64|Array<null>>} The initial state values\n\t */\n\tfunction getNewState(variant)\n\t{\n\t\tvar retVal = [], H_trunc, H_full, i;\n\n\t\tif ((\"SHA-1\" === variant) && ((1 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tretVal = [\n\t\t\t\t0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0\n\t\t\t];\n\t\t}\n\t\telse if ((variant.lastIndexOf(\"SHA-\", 0) === 0) && ((6 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tH_trunc = [\n\t\t\t\t0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n\t\t\t\t0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n\t\t\t];\n\t\t\tH_full = [\n\t\t\t\t0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,\n\t\t\t\t0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\n\t\t\t];\n\n\t\t\tswitch (variant)\n\t\t\t{\n\t\t\tcase \"SHA-224\":\n\t\t\t\tretVal = H_trunc;\n\t\t\t\tbreak;\n\t\t\tcase \"SHA-256\":\n\t\t\t\tretVal = H_full;\n\t\t\t\tbreak;\n\t\t\tcase \"SHA-384\":\n\t\t\t\tretVal = [\n\t\t\t\t\tnew Int_64(0xcbbb9d5d, H_trunc[0]),\n\t\t\t\t\tnew Int_64(0x0629a292a, H_trunc[1]),\n\t\t\t\t\tnew Int_64(0x9159015a, H_trunc[2]),\n\t\t\t\t\tnew Int_64(0x0152fecd8, H_trunc[3]),\n\t\t\t\t\tnew Int_64(0x67332667, H_trunc[4]),\n\t\t\t\t\tnew Int_64(0x98eb44a87, H_trunc[5]),\n\t\t\t\t\tnew Int_64(0xdb0c2e0d, H_trunc[6]),\n\t\t\t\t\tnew Int_64(0x047b5481d, H_trunc[7])\n\t\t\t\t];\n\t\t\t\tbreak;\n\t\t\tcase \"SHA-512\":\n\t\t\t\tretVal = [\n\t\t\t\t\tnew Int_64(H_full[0], 0xf3bcc908),\n\t\t\t\t\tnew Int_64(H_full[1], 0x84caa73b),\n\t\t\t\t\tnew Int_64(H_full[2], 0xfe94f82b),\n\t\t\t\t\tnew Int_64(H_full[3], 0x5f1d36f1),\n\t\t\t\t\tnew Int_64(H_full[4], 0xade682d1),\n\t\t\t\t\tnew Int_64(H_full[5], 0x2b3e6c1f),\n\t\t\t\t\tnew Int_64(H_full[6], 0xfb41bd6b),\n\t\t\t\t\tnew Int_64(H_full[7], 0x137e2179)\n\t\t\t\t];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unknown SHA variant\");\n\t\t\t}\n\t\t}\n\t\telse if (((variant.lastIndexOf(\"SHA3-\", 0) === 0) || (variant.lastIndexOf(\"SHAKE\", 0) === 0)) &&\n\t\t\t((8 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tfor (i = 0; i < 5; i += 1)\n\t\t\t{\n\t\t\t\tretVal[i] = [new Int_64(0, 0), new Int_64(0, 0), new Int_64(0, 0), new Int_64(0, 0), new Int_64(0, 0)];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new Error(\"No SHA variants supported\");\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * Performs a round of SHA-1 hashing over a 512-byte block\n\t *\n\t * @private\n\t * @param {Array<number>} block The binary array representation of the\n\t *   block to hash\n\t * @param {Array<number>} H The intermediate H values from a previous\n\t *   round\n\t * @return {Array<number>} The resulting H values\n\t */\n\tfunction roundSHA1(block, H)\n\t{\n\t\tvar W = [], a, b, c, d, e, T, ch = ch_32, parity = parity_32,\n\t\t\tmaj = maj_32, rotl = rotl_32, safeAdd_2 = safeAdd_32_2, t,\n\t\t\tsafeAdd_5 = safeAdd_32_5;\n\n\t\ta = H[0];\n\t\tb = H[1];\n\t\tc = H[2];\n\t\td = H[3];\n\t\te = H[4];\n\n\t\tfor (t = 0; t < 80; t += 1)\n\t\t{\n\t\t\tif (t < 16)\n\t\t\t{\n\t\t\t\tW[t] = block[t];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tW[t] = rotl(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n\t\t\t}\n\n\t\t\tif (t < 20)\n\t\t\t{\n\t\t\t\tT = safeAdd_5(rotl(a, 5), ch(b, c, d), e, 0x5a827999, W[t]);\n\t\t\t}\n\t\t\telse if (t < 40)\n\t\t\t{\n\t\t\t\tT = safeAdd_5(rotl(a, 5), parity(b, c, d), e, 0x6ed9eba1, W[t]);\n\t\t\t}\n\t\t\telse if (t < 60)\n\t\t\t{\n\t\t\t\tT = safeAdd_5(rotl(a, 5), maj(b, c, d), e, 0x8f1bbcdc, W[t]);\n\t\t\t} else {\n\t\t\t\tT = safeAdd_5(rotl(a, 5), parity(b, c, d), e, 0xca62c1d6, W[t]);\n\t\t\t}\n\n\t\t\te = d;\n\t\t\td = c;\n\t\t\tc = rotl(b, 30);\n\t\t\tb = a;\n\t\t\ta = T;\n\t\t}\n\n\t\tH[0] = safeAdd_2(a, H[0]);\n\t\tH[1] = safeAdd_2(b, H[1]);\n\t\tH[2] = safeAdd_2(c, H[2]);\n\t\tH[3] = safeAdd_2(d, H[3]);\n\t\tH[4] = safeAdd_2(e, H[4]);\n\n\t\treturn H;\n\t}\n\n\t/**\n\t * Finalizes the SHA-1 hash\n\t *\n\t * @private\n\t * @param {Array<number>} remainder Any leftover unprocessed packed ints\n\t *   that still need to be processed\n\t * @param {number} remainderBinLen The number of bits in remainder\n\t * @param {number} processedBinLen The number of bits already\n\t *   processed\n\t * @param {Array<number>} H The intermediate H values from a previous\n\t *   round\n\t * @param {number} outputLen Unused for this variant\n\t * @return {Array<number>} The array of integers representing the SHA-1\n\t *   hash of message\n\t */\n\tfunction finalizeSHA1(remainder, remainderBinLen, processedBinLen, H, outputLen)\n\t{\n\t\tvar i, appendedMessageLength, offset, totalLen;\n\n\t\t/* The 65 addition is a hack but it works.  The correct number is\n\t\t   actually 72 (64 + 8) but the below math fails if\n\t\t   remainderBinLen + 72 % 512 = 0. Since remainderBinLen % 8 = 0,\n\t\t   \"shorting\" the addition is OK. */\n\t\toffset = (((remainderBinLen + 65) >>> 9) << 4) + 15;\n\t\twhile (remainder.length <= offset)\n\t\t{\n\t\t\tremainder.push(0);\n\t\t}\n\t\t/* Append '1' at the end of the binary string */\n\t\tremainder[remainderBinLen >>> 5] |= 0x80 << (24 - (remainderBinLen % 32));\n\t\t/* Append length of binary string in the position such that the new\n\t\t * length is a multiple of 512.  Logic does not work for even multiples\n\t\t * of 512 but there can never be even multiples of 512. JavaScript\n\t\t * numbers are limited to 2^53 so it's \"safe\" to treat the totalLen as\n\t\t * a 64-bit integer. */\n\t\ttotalLen = remainderBinLen + processedBinLen;\n\t\tremainder[offset] = totalLen & 0xFFFFFFFF;\n\t\t/* Bitwise operators treat the operand as a 32-bit number so need to\n\t\t * use hacky division and round to get access to upper 32-ish bits */\n\t\tremainder[offset - 1] = (totalLen / TWO_PWR_32) | 0;\n\n\t\tappendedMessageLength = remainder.length;\n\n\t\t/* This will always be at least 1 full chunk */\n\t\tfor (i = 0; i < appendedMessageLength; i += 16)\n\t\t{\n\t\t\tH = roundSHA1(remainder.slice(i, i + 16), H);\n\t\t}\n\n\t\treturn H;\n\t}\n\n\t/* Put this here so the K arrays aren't put on the stack for every block */\n\tvar K_sha2, K_sha512, r_sha3, rc_sha3;\n\tif ((6 & SUPPORTED_ALGS) !== 0)\n\t{\n\t\tK_sha2 = [\n\t\t\t0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,\n\t\t\t0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,\n\t\t\t0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\n\t\t\t0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,\n\t\t\t0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,\n\t\t\t0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\n\t\t\t0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,\n\t\t\t0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,\n\t\t\t0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\n\t\t\t0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,\n\t\t\t0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,\n\t\t\t0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\n\t\t\t0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,\n\t\t\t0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,\n\t\t\t0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\n\t\t\t0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\n\t\t];\n\n\t\tif ((4 & SUPPORTED_ALGS) !== 0)\n\t\t{\n\t\t\t K_sha512 = [\n\t\t\t\tnew Int_64(K_sha2[ 0], 0xd728ae22), new Int_64(K_sha2[ 1], 0x23ef65cd),\n\t\t\t\tnew Int_64(K_sha2[ 2], 0xec4d3b2f), new Int_64(K_sha2[ 3], 0x8189dbbc),\n\t\t\t\tnew Int_64(K_sha2[ 4], 0xf348b538), new Int_64(K_sha2[ 5], 0xb605d019),\n\t\t\t\tnew Int_64(K_sha2[ 6], 0xaf194f9b), new Int_64(K_sha2[ 7], 0xda6d8118),\n\t\t\t\tnew Int_64(K_sha2[ 8], 0xa3030242), new Int_64(K_sha2[ 9], 0x45706fbe),\n\t\t\t\tnew Int_64(K_sha2[10], 0x4ee4b28c), new Int_64(K_sha2[11], 0xd5ffb4e2),\n\t\t\t\tnew Int_64(K_sha2[12], 0xf27b896f), new Int_64(K_sha2[13], 0x3b1696b1),\n\t\t\t\tnew Int_64(K_sha2[14], 0x25c71235), new Int_64(K_sha2[15], 0xcf692694),\n\t\t\t\tnew Int_64(K_sha2[16], 0x9ef14ad2), new Int_64(K_sha2[17], 0x384f25e3),\n\t\t\t\tnew Int_64(K_sha2[18], 0x8b8cd5b5), new Int_64(K_sha2[19], 0x77ac9c65),\n\t\t\t\tnew Int_64(K_sha2[20], 0x592b0275), new Int_64(K_sha2[21], 0x6ea6e483),\n\t\t\t\tnew Int_64(K_sha2[22], 0xbd41fbd4), new Int_64(K_sha2[23], 0x831153b5),\n\t\t\t\tnew Int_64(K_sha2[24], 0xee66dfab), new Int_64(K_sha2[25], 0x2db43210),\n\t\t\t\tnew Int_64(K_sha2[26], 0x98fb213f), new Int_64(K_sha2[27], 0xbeef0ee4),\n\t\t\t\tnew Int_64(K_sha2[28], 0x3da88fc2), new Int_64(K_sha2[29], 0x930aa725),\n\t\t\t\tnew Int_64(K_sha2[30], 0xe003826f), new Int_64(K_sha2[31], 0x0a0e6e70),\n\t\t\t\tnew Int_64(K_sha2[32], 0x46d22ffc), new Int_64(K_sha2[33], 0x5c26c926),\n\t\t\t\tnew Int_64(K_sha2[34], 0x5ac42aed), new Int_64(K_sha2[35], 0x9d95b3df),\n\t\t\t\tnew Int_64(K_sha2[36], 0x8baf63de), new Int_64(K_sha2[37], 0x3c77b2a8),\n\t\t\t\tnew Int_64(K_sha2[38], 0x47edaee6), new Int_64(K_sha2[39], 0x1482353b),\n\t\t\t\tnew Int_64(K_sha2[40], 0x4cf10364), new Int_64(K_sha2[41], 0xbc423001),\n\t\t\t\tnew Int_64(K_sha2[42], 0xd0f89791), new Int_64(K_sha2[43], 0x0654be30),\n\t\t\t\tnew Int_64(K_sha2[44], 0xd6ef5218), new Int_64(K_sha2[45], 0x5565a910),\n\t\t\t\tnew Int_64(K_sha2[46], 0x5771202a), new Int_64(K_sha2[47], 0x32bbd1b8),\n\t\t\t\tnew Int_64(K_sha2[48], 0xb8d2d0c8), new Int_64(K_sha2[49], 0x5141ab53),\n\t\t\t\tnew Int_64(K_sha2[50], 0xdf8eeb99), new Int_64(K_sha2[51], 0xe19b48a8),\n\t\t\t\tnew Int_64(K_sha2[52], 0xc5c95a63), new Int_64(K_sha2[53], 0xe3418acb),\n\t\t\t\tnew Int_64(K_sha2[54], 0x7763e373), new Int_64(K_sha2[55], 0xd6b2b8a3),\n\t\t\t\tnew Int_64(K_sha2[56], 0x5defb2fc), new Int_64(K_sha2[57], 0x43172f60),\n\t\t\t\tnew Int_64(K_sha2[58], 0xa1f0ab72), new Int_64(K_sha2[59], 0x1a6439ec),\n\t\t\t\tnew Int_64(K_sha2[60], 0x23631e28), new Int_64(K_sha2[61], 0xde82bde9),\n\t\t\t\tnew Int_64(K_sha2[62], 0xb2c67915), new Int_64(K_sha2[63], 0xe372532b),\n\t\t\t\tnew Int_64(0xca273ece, 0xea26619c), new Int_64(0xd186b8c7, 0x21c0c207),\n\t\t\t\tnew Int_64(0xeada7dd6, 0xcde0eb1e), new Int_64(0xf57d4f7f, 0xee6ed178),\n\t\t\t\tnew Int_64(0x06f067aa, 0x72176fba), new Int_64(0x0a637dc5, 0xa2c898a6),\n\t\t\t\tnew Int_64(0x113f9804, 0xbef90dae), new Int_64(0x1b710b35, 0x131c471b),\n\t\t\t\tnew Int_64(0x28db77f5, 0x23047d84), new Int_64(0x32caab7b, 0x40c72493),\n\t\t\t\tnew Int_64(0x3c9ebe0a, 0x15c9bebc), new Int_64(0x431d67c4, 0x9c100d4c),\n\t\t\t\tnew Int_64(0x4cc5d4be, 0xcb3e42b6), new Int_64(0x597f299c, 0xfc657e2a),\n\t\t\t\tnew Int_64(0x5fcb6fab, 0x3ad6faec), new Int_64(0x6c44198c, 0x4a475817)\n\t\t\t];\n\t\t}\n\t}\n\tif ((8 & SUPPORTED_ALGS) !== 0)\n\t{\n\t\trc_sha3 = [\n\t\t\tnew Int_64(0x00000000, 0x00000001), new Int_64(0x00000000, 0x00008082),\n\t\t\tnew Int_64(0x80000000, 0x0000808A), new Int_64(0x80000000, 0x80008000),\n\t\t\tnew Int_64(0x00000000, 0x0000808B), new Int_64(0x00000000, 0x80000001),\n\t\t\tnew Int_64(0x80000000, 0x80008081), new Int_64(0x80000000, 0x00008009),\n\t\t\tnew Int_64(0x00000000, 0x0000008A), new Int_64(0x00000000, 0x00000088),\n\t\t\tnew Int_64(0x00000000, 0x80008009), new Int_64(0x00000000, 0x8000000A),\n\t\t\tnew Int_64(0x00000000, 0x8000808B), new Int_64(0x80000000, 0x0000008B),\n\t\t\tnew Int_64(0x80000000, 0x00008089), new Int_64(0x80000000, 0x00008003),\n\t\t\tnew Int_64(0x80000000, 0x00008002), new Int_64(0x80000000, 0x00000080),\n\t\t\tnew Int_64(0x00000000, 0x0000800A), new Int_64(0x80000000, 0x8000000A),\n\t\t\tnew Int_64(0x80000000, 0x80008081), new Int_64(0x80000000, 0x00008080),\n\t\t\tnew Int_64(0x00000000, 0x80000001), new Int_64(0x80000000, 0x80008008)\n\t\t];\n\n\t\tr_sha3 = [\n\t\t\t[ 0, 36,  3, 41, 18],\n\t\t\t[ 1, 44, 10, 45,  2],\n\t\t\t[62,  6, 43, 15, 61],\n\t\t\t[28, 55, 25, 21, 56],\n\t\t\t[27, 20, 39,  8, 14]\n\t\t];\n\t}\n\n\t/**\n\t * Performs a round of SHA-2 hashing over a block\n\t *\n\t * @private\n\t * @param {Array<number>} block The binary array representation of the\n\t *   block to hash\n\t * @param {Array<number|Int_64>} H The intermediate H values from a previous\n\t *   round\n\t * @param {string} variant The desired SHA-2 variant\n\t * @return {Array<number|Int_64>} The resulting H values\n\t */\n\tfunction roundSHA2(block, H, variant)\n\t{\n\t\tvar a, b, c, d, e, f, g, h, T1, T2, numRounds, t, binaryStringMult,\n\t\t\tsafeAdd_2, safeAdd_4, safeAdd_5, gamma0, gamma1, sigma0, sigma1,\n\t\t\tch, maj, Int, W = [], int1, int2, offset, K;\n\n\t\t/* Set up the various function handles and variable for the specific\n\t\t * variant */\n\t\tif ((variant === \"SHA-224\" || variant === \"SHA-256\") &&\n\t\t\t((2 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\t/* 32-bit variant */\n\t\t\tnumRounds = 64;\n\t\t\tbinaryStringMult = 1;\n\t\t\tInt = Number;\n\t\t\tsafeAdd_2 = safeAdd_32_2;\n\t\t\tsafeAdd_4 = safeAdd_32_4;\n\t\t\tsafeAdd_5 = safeAdd_32_5;\n\t\t\tgamma0 = gamma0_32;\n\t\t\tgamma1 = gamma1_32;\n\t\t\tsigma0 = sigma0_32;\n\t\t\tsigma1 = sigma1_32;\n\t\t\tmaj = maj_32;\n\t\t\tch = ch_32;\n\t\t\tK = K_sha2;\n\t\t}\n\t\telse if ((variant === \"SHA-384\" || variant === \"SHA-512\") &&\n\t\t\t((4 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\t/* 64-bit variant */\n\t\t\tnumRounds = 80;\n\t\t\tbinaryStringMult = 2;\n\t\t\tInt = Int_64;\n\t\t\tsafeAdd_2 = safeAdd_64_2;\n\t\t\tsafeAdd_4 = safeAdd_64_4;\n\t\t\tsafeAdd_5 = safeAdd_64_5;\n\t\t\tgamma0 = gamma0_64;\n\t\t\tgamma1 = gamma1_64;\n\t\t\tsigma0 = sigma0_64;\n\t\t\tsigma1 = sigma1_64;\n\t\t\tmaj = maj_64;\n\t\t\tch = ch_64;\n\t\t\tK = K_sha512;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new Error(\"Unexpected error in SHA-2 implementation\");\n\t\t}\n\n\t\ta = H[0];\n\t\tb = H[1];\n\t\tc = H[2];\n\t\td = H[3];\n\t\te = H[4];\n\t\tf = H[5];\n\t\tg = H[6];\n\t\th = H[7];\n\n\t\tfor (t = 0; t < numRounds; t += 1)\n\t\t{\n\t\t\tif (t < 16)\n\t\t\t{\n\t\t\t\toffset = t * binaryStringMult;\n\t\t\t\tint1 = (block.length <= offset) ? 0 : block[offset];\n\t\t\t\tint2 = (block.length <= offset + 1) ? 0 : block[offset + 1];\n\t\t\t\t/* Bit of a hack - for 32-bit, the second term is ignored */\n\t\t\t\tW[t] = new Int(int1, int2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tW[t] = safeAdd_4(\n\t\t\t\t\t\tgamma1(W[t - 2]), W[t - 7],\n\t\t\t\t\t\tgamma0(W[t - 15]), W[t - 16]\n\t\t\t\t\t);\n\t\t\t}\n\n\t\t\tT1 = safeAdd_5(h, sigma1(e), ch(e, f, g), K[t], W[t]);\n\t\t\tT2 = safeAdd_2(sigma0(a), maj(a, b, c));\n\t\t\th = g;\n\t\t\tg = f;\n\t\t\tf = e;\n\t\t\te = safeAdd_2(d, T1);\n\t\t\td = c;\n\t\t\tc = b;\n\t\t\tb = a;\n\t\t\ta = safeAdd_2(T1, T2);\n\t\t}\n\n\t\tH[0] = safeAdd_2(a, H[0]);\n\t\tH[1] = safeAdd_2(b, H[1]);\n\t\tH[2] = safeAdd_2(c, H[2]);\n\t\tH[3] = safeAdd_2(d, H[3]);\n\t\tH[4] = safeAdd_2(e, H[4]);\n\t\tH[5] = safeAdd_2(f, H[5]);\n\t\tH[6] = safeAdd_2(g, H[6]);\n\t\tH[7] = safeAdd_2(h, H[7]);\n\n\t\treturn H;\n\t}\n\n\t/**\n\t * Finalizes the SHA-2 hash\n\t *\n\t * @private\n\t * @param {Array<number>} remainder Any leftover unprocessed packed ints\n\t *   that still need to be processed\n\t * @param {number} remainderBinLen The number of bits in remainder\n\t * @param {number} processedBinLen The number of bits already\n\t *   processed\n\t * @param {Array<number|Int_64>} H The intermediate H values from a previous\n\t *   round\n\t * @param {string} variant The desired SHA-2 variant\n\t * @param {number} outputLen Unused for this variant\n\t * @return {Array<number>} The array of integers representing the SHA-2\n\t *   hash of message\n\t */\n\tfunction finalizeSHA2(remainder, remainderBinLen, processedBinLen, H, variant, outputLen)\n\t{\n\t\tvar i, appendedMessageLength, offset, retVal, binaryStringInc, totalLen;\n\n\t\tif ((variant === \"SHA-224\" || variant === \"SHA-256\") &&\n\t\t\t((2 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\t/* 32-bit variant */\n\t\t\t/* The 65 addition is a hack but it works.  The correct number is\n\t\t\t   actually 72 (64 + 8) but the below math fails if\n\t\t\t   remainderBinLen + 72 % 512 = 0. Since remainderBinLen % 8 = 0,\n\t\t\t   \"shorting\" the addition is OK. */\n\t\t\toffset = (((remainderBinLen + 65) >>> 9) << 4) + 15;\n\t\t\tbinaryStringInc = 16;\n\t\t}\n\t\telse if ((variant === \"SHA-384\" || variant === \"SHA-512\") &&\n\t\t\t((4 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\t/* 64-bit variant */\n\t\t\t/* The 129 addition is a hack but it works.  The correct number is\n\t\t\t   actually 136 (128 + 8) but the below math fails if\n\t\t\t   remainderBinLen + 136 % 1024 = 0. Since remainderBinLen % 8 = 0,\n\t\t\t   \"shorting\" the addition is OK. */\n\t\t\toffset = (((remainderBinLen + 129) >>> 10) << 5) + 31;\n\t\t\tbinaryStringInc = 32;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new Error(\"Unexpected error in SHA-2 implementation\");\n\t\t}\n\n\t\twhile (remainder.length <= offset)\n\t\t{\n\t\t\tremainder.push(0);\n\t\t}\n\t\t/* Append '1' at the end of the binary string */\n\t\tremainder[remainderBinLen >>> 5] |= 0x80 << (24 - remainderBinLen % 32);\n\t\t/* Append length of binary string in the position such that the new\n\t\t * length is correct. JavaScript numbers are limited to 2^53 so it's\n\t\t * \"safe\" to treat the totalLen as a 64-bit integer. */\n\t\ttotalLen = remainderBinLen + processedBinLen;\n\t\tremainder[offset] = totalLen & 0xFFFFFFFF;\n\t\t/* Bitwise operators treat the operand as a 32-bit number so need to\n\t\t * use hacky division and round to get access to upper 32-ish bits */\n\t\tremainder[offset - 1] = (totalLen / TWO_PWR_32) | 0;\n\n\t\tappendedMessageLength = remainder.length;\n\n\t\t/* This will always be at least 1 full chunk */\n\t\tfor (i = 0; i < appendedMessageLength; i += binaryStringInc)\n\t\t{\n\t\t\tH = roundSHA2(remainder.slice(i, i + binaryStringInc), H, variant);\n\t\t}\n\n\t\tif ((\"SHA-224\" === variant) && ((2 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tretVal = [\n\t\t\t\tH[0], H[1], H[2], H[3],\n\t\t\t\tH[4], H[5], H[6]\n\t\t\t];\n\t\t}\n\t\telse if ((\"SHA-256\" === variant) && ((2 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tretVal = H;\n\t\t}\n\t\telse if ((\"SHA-384\" === variant) && ((4 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tretVal = [\n\t\t\t\tH[0].highOrder, H[0].lowOrder,\n\t\t\t\tH[1].highOrder, H[1].lowOrder,\n\t\t\t\tH[2].highOrder, H[2].lowOrder,\n\t\t\t\tH[3].highOrder, H[3].lowOrder,\n\t\t\t\tH[4].highOrder, H[4].lowOrder,\n\t\t\t\tH[5].highOrder, H[5].lowOrder\n\t\t\t];\n\t\t}\n\t\telse if ((\"SHA-512\" === variant) && ((4 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tretVal = [\n\t\t\t\tH[0].highOrder, H[0].lowOrder,\n\t\t\t\tH[1].highOrder, H[1].lowOrder,\n\t\t\t\tH[2].highOrder, H[2].lowOrder,\n\t\t\t\tH[3].highOrder, H[3].lowOrder,\n\t\t\t\tH[4].highOrder, H[4].lowOrder,\n\t\t\t\tH[5].highOrder, H[5].lowOrder,\n\t\t\t\tH[6].highOrder, H[6].lowOrder,\n\t\t\t\tH[7].highOrder, H[7].lowOrder\n\t\t\t];\n\t\t}\n\t\telse /* This should never be reached */\n\t\t{\n\t\t\tthrow new Error(\"Unexpected error in SHA-2 implementation\");\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * Performs a round of SHA-3 hashing over a block\n\t *\n\t * @private\n\t * @param {Array<number>|null} block The binary array representation of the\n\t *   block to hash\n\t * @param {Array<Array<Int_64>>} state The binary array representation of the\n\t *   block to hash\n\t * @return {Array<Array<Int_64>>} The resulting state value\n\t */\n\tfunction roundSHA3(block, state)\n\t{\n\t\tvar round, x, y, B, C = [], D = [];\n\n\t\tif (null !== block)\n\t\t{\n\t\t\tfor (x = 0; x < block.length; x+=2)\n\t\t\t{\n\t\t\t\tstate[(x >>> 1) % 5][((x >>> 1) / 5) | 0] = xor_64_2(\n\t\t\t\t\tstate[(x >>> 1) % 5][((x >>> 1) / 5) | 0],\n\t\t\t\t\tnew Int_64(block[x + 1], block[x])\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tfor (round = 0; round < 24; round += 1)\n\t\t{\n\t\t\t/* getNewState doesn't care about variant beyond SHA3 so feed it a\n\t\t\t   value that triggers the getNewState \"if\" statement\n\t\t\t*/\n\t\t\tB = getNewState(\"SHA3-\");\n\n\t\t\t/* Perform theta step */\n\t\t\tfor (x = 0; x < 5; x += 1)\n\t\t\t{\n\t\t\t\tC[x] = xor_64_5(state[x][0], state[x][1], state[x][2],\n\t\t\t\t\tstate[x][3], state[x][4]);\n\t\t\t}\n\t\t\tfor (x = 0; x < 5; x += 1)\n\t\t\t{\n\t\t\t\tD[x] = xor_64_2(C[(x + 4) % 5], rotl_64(C[(x + 1) % 5], 1));\n\t\t\t}\n\t\t\tfor (x = 0; x < 5; x += 1)\n\t\t\t{\n\t\t\t\tfor (y = 0; y < 5; y += 1)\n\t\t\t\t{\n\t\t\t\t\tstate[x][y] = xor_64_2(state[x][y], D[x]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Perform combined ro and pi steps */\n\t\t\tfor (x = 0; x < 5; x += 1)\n\t\t\t{\n\t\t\t\tfor (y = 0; y < 5; y += 1)\n\t\t\t\t{\n\t\t\t\t\tB[y][(2 * x + 3 * y) % 5] = rotl_64(\n\t\t\t\t\t\tstate[x][y],\n\t\t\t\t\t\tr_sha3[x][y]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Perform chi step */\n\t\t\tfor (x = 0; x < 5; x += 1)\n\t\t\t{\n\t\t\t\tfor (y = 0; y < 5; y += 1)\n\t\t\t\t{\n\t\t\t\t\tstate[x][y] = xor_64_2(\n\t\t\t\t\t\tB[x][y],\n\t\t\t\t\t\tnew Int_64(\n\t\t\t\t\t\t\t~(B[(x + 1) % 5][y].highOrder) & B[(x + 2) % 5][y].highOrder,\n\t\t\t\t\t\t\t~(B[(x + 1) % 5][y].lowOrder)  & B[(x + 2) % 5][y].lowOrder\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Perform iota step */\n\t\t\tstate[0][0] = xor_64_2(state[0][0], rc_sha3[round]);\n\t\t}\n\n\t\treturn state;\n\t}\n\n\t/**\n\t * Finalizes the SHA-3 hash\n\t *\n\t * @private\n\t * @param {Array<number>} remainder Any leftover unprocessed packed ints\n\t *   that still need to be processed\n\t * @param {number} remainderBinLen The number of bits in remainder\n\t * @param {number} processedBinLen The number of bits already\n\t *   processed\n\t * @param {Array<Array<Int_64>>} state The state from a previous round\n\t * @param {number} blockSize The block size/rate of the variant in bits\n\t * @param {number} delimiter The delimiter value for the variant\n\t * @param {number} outputLen The output length for the variant in bits\n\t * @return {Array<number>} The array of integers representing the SHA-3\n\t *   hash of message\n\t */\n\tfunction finalizeSHA3(remainder, remainderBinLen, processedBinLen, state, blockSize, delimiter, outputLen)\n\t{\n\t\tvar i, retVal = [], binaryStringInc = blockSize >>> 5, state_offset = 0,\n\t\t\tremainderIntLen = remainderBinLen >>> 5, temp;\n\n\n\t\t/* Process as many blocks as possible, some may be here for multiple rounds\n\t\t   with SHAKE\n\t\t*/\n\t\tfor (i = 0; i < remainderIntLen && remainderBinLen >= blockSize; i += binaryStringInc)\n\t\t{\n\t\t\tstate = roundSHA3(remainder.slice(i, i + binaryStringInc), state);\n\t\t\tremainderBinLen -= blockSize;\n\t\t}\n\n\t\tremainder = remainder.slice(i);\n\t\tremainderBinLen = remainderBinLen % blockSize;\n\n\t\t/* Pad out the remainder to a full block */\n\t\twhile (remainder.length < binaryStringInc)\n\t\t{\n\t\t\tremainder.push(0);\n\t\t}\n\n\t\t/* Find the next \"empty\" byte for the 0x80 and append it via an xor */\n\t\ti = remainderBinLen >>> 3;\n\t\tremainder[i >> 2] ^= delimiter << (8 * (i % 4));\n\n\t\tremainder[binaryStringInc - 1] ^= 0x80000000;\n\t\tstate = roundSHA3(remainder, state);\n\n\t\twhile (retVal.length * 32 < outputLen)\n\t\t{\n\t\t\ttemp = state[state_offset % 5][(state_offset / 5) | 0];\n\t\t\tretVal.push(temp.lowOrder);\n\t\t\tif (retVal.length * 32 >= outputLen)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretVal.push(temp.highOrder);\n\t\t\tstate_offset += 1;\n\n\t\t\tif (0 === ((state_offset * 64) % blockSize))\n\t\t\t{\n\t\t\t\troundSHA3(null, state);\n\t\t\t}\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * jsSHA is the workhorse of the library.  Instantiate it with the string to\n\t * be hashed as the parameter\n\t *\n\t * @constructor\n\t * @this {jsSHA}\n\t * @param {string} variant The desired SHA variant (SHA-1, SHA-224, SHA-256,\n\t *   SHA-384, SHA-512, SHA3-224, SHA3-256, SHA3-384, or SHA3-512)\n\t * @param {string} inputFormat The format of srcString: HEX, TEXT, B64,\n\t *   BYTES, or ARRAYBUFFER\n\t * @param {{encoding: (string|undefined), numRounds: (number|undefined)}=}\n\t *   options Optional values\n\t */\n\tvar jsSHA = function(variant, inputFormat, options)\n\t{\n\t\tvar processedLen = 0, remainder = [], remainderLen = 0, utfType,\n\t\t\tintermediateState, converterFunc, shaVariant = variant, outputBinLen,\n\t\t\tvariantBlockSize, roundFunc, finalizeFunc, stateCloneFunc,\n\t\t\thmacKeySet = false, keyWithIPad = [], keyWithOPad = [], numRounds,\n\t\t\tupdatedCalled = false, inputOptions, isSHAKE = false, bigEndianMod = -1;\n\n\t\tinputOptions = options || {};\n\t\tutfType = inputOptions[\"encoding\"] || \"UTF8\";\n\t\tnumRounds = inputOptions[\"numRounds\"] || 1;\n\n\t\tif ((numRounds !== parseInt(numRounds, 10)) || (1 > numRounds))\n\t\t{\n\t\t\tthrow new Error(\"numRounds must a integer >= 1\");\n\t\t}\n\n\t\tif ((\"SHA-1\" === shaVariant) && ((1 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tvariantBlockSize = 512;\n\t\t\troundFunc = roundSHA1;\n\t\t\tfinalizeFunc = finalizeSHA1;\n\t\t\toutputBinLen = 160;\n\t\t\tstateCloneFunc = function(state) { return state.slice();};\n\t\t}\n\t\telse if ((shaVariant.lastIndexOf(\"SHA-\", 0) === 0) && ((6 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\troundFunc = function (block, H) {\n\t\t\t\treturn roundSHA2(block, H, shaVariant);\n\t\t\t};\n\t\t\tfinalizeFunc = function (remainder, remainderBinLen, processedBinLen, H, outputLen)\n\t\t\t{\n\t\t\t\treturn finalizeSHA2(remainder, remainderBinLen, processedBinLen, H, shaVariant, outputLen);\n\t\t\t};\n\t\t\tstateCloneFunc = function(state) { return state.slice(); };\n\n\t\t\tif ((\"SHA-224\" === shaVariant) && ((2 & SUPPORTED_ALGS) !== 0))\n\t\t\t{\n\t\t\t\tvariantBlockSize = 512;\n\t\t\t\toutputBinLen = 224;\n\t\t\t}\n\t\t\telse if ((\"SHA-256\" === shaVariant) && ((2 & SUPPORTED_ALGS) !== 0))\n\t\t\t{\n\t\t\t\tvariantBlockSize = 512;\n\t\t\t\toutputBinLen = 256;\n\t\t\t}\n\t\t\telse if ((\"SHA-384\" === shaVariant) && ((4 & SUPPORTED_ALGS) !== 0))\n\t\t\t{\n\t\t\t\tvariantBlockSize = 1024;\n\t\t\t\toutputBinLen = 384;\n\t\t\t}\n\t\t\telse if ((\"SHA-512\" === shaVariant) && ((4 & SUPPORTED_ALGS) !== 0))\n\t\t\t{\n\t\t\t\tvariantBlockSize = 1024;\n\t\t\t\toutputBinLen = 512;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new Error(\"Chosen SHA variant is not supported\");\n\t\t\t}\n\t\t}\n\t\telse if (((shaVariant.lastIndexOf(\"SHA3-\", 0) === 0) || (shaVariant.lastIndexOf(\"SHAKE\", 0) === 0)) &&\n\t\t\t((8 & SUPPORTED_ALGS) !== 0))\n\t\t{\n\t\t\tvar delimiter = 0x06;\n\n\t\t\troundFunc = roundSHA3;\n\t\t\tstateCloneFunc = function(state) { return cloneSHA3State(state);};\n\t\t\tbigEndianMod = 1;\n\n\t\t\tif (\"SHA3-224\" === shaVariant)\n\t\t\t{\n\t\t\t\tvariantBlockSize = 1152;\n\t\t\t\toutputBinLen = 224;\n\n\t\t\t}\n\t\t\telse if (\"SHA3-256\" === shaVariant)\n\t\t\t{\n\t\t\t\tvariantBlockSize = 1088;\n\t\t\t\toutputBinLen = 256;\n\t\t\t}\n\t\t\telse if (\"SHA3-384\" === shaVariant)\n\t\t\t{\n\t\t\t\tvariantBlockSize = 832;\n\t\t\t\toutputBinLen = 384;\n\t\t\t}\n\t\t\telse if (\"SHA3-512\" === shaVariant)\n\t\t\t{\n\t\t\t\tvariantBlockSize = 576;\n\t\t\t\toutputBinLen = 512;\n\t\t\t}\n\t\t\telse if (\"SHAKE128\" === shaVariant)\n\t\t\t{\n\t\t\t\tvariantBlockSize = 1344;\n\t\t\t\toutputBinLen = -1;\n\t\t\t\tdelimiter = 0x1F;\n\t\t\t\tisSHAKE = true;\n\t\t\t}\n\t\t\telse if (\"SHAKE256\" === shaVariant)\n\t\t\t{\n\t\t\t\tvariantBlockSize = 1088;\n\t\t\t\toutputBinLen = -1;\n\t\t\t\tdelimiter = 0x1F;\n\t\t\t\tisSHAKE = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new Error(\"Chosen SHA variant is not supported\");\n\t\t\t}\n\t\t\tfinalizeFunc = function (remainder, remainderBinLen, processedBinLen, state, outputLen)\n\t\t\t{\n\t\t\t\treturn finalizeSHA3(remainder, remainderBinLen, processedBinLen, state, variantBlockSize, delimiter, outputLen);\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new Error(\"Chosen SHA variant is not supported\");\n\t\t}\n\t\tconverterFunc = getStrConverter(inputFormat, utfType, bigEndianMod);\n\t\tintermediateState = getNewState(shaVariant);\n\n\t\t/**\n\t\t * Sets the HMAC key for an eventual getHMAC call.  Must be called\n\t\t * immediately after jsSHA object instantiation\n\t\t *\n\t\t * @expose\n\t\t * @param {string|ArrayBuffer} key The key used to calculate the HMAC\n\t\t * @param {string} inputFormat The format of key, HEX, TEXT, B64, BYTES,\n\t\t *   or ARRAYBUFFER\n\t\t * @param {{encoding : (string|undefined)}=} options Associative array\n\t\t *   of input format options\n\t\t */\n\t\tthis.setHMACKey = function(key, inputFormat, options)\n\t\t{\n\t\t\tvar keyConverterFunc, convertRet, keyBinLen, keyToUse, blockByteSize,\n\t\t\t\ti, lastArrayIndex, keyOptions;\n\n\t\t\tif (true === hmacKeySet)\n\t\t\t{\n\t\t\t\tthrow new Error(\"HMAC key already set\");\n\t\t\t}\n\n\t\t\tif (true === updatedCalled)\n\t\t\t{\n\t\t\t\tthrow new Error(\"Cannot set HMAC key after calling update\");\n\t\t\t}\n\n\t\t\tif ((isSHAKE === true) && ((8 & SUPPORTED_ALGS) !== 0))\n\t\t\t{\n\t\t\t\tthrow new Error(\"SHAKE is not supported for HMAC\");\n\t\t\t}\n\n\t\t\tkeyOptions = options || {};\n\t\t\tutfType = keyOptions[\"encoding\"] || \"UTF8\";\n\n\t\t\tkeyConverterFunc = getStrConverter(inputFormat, utfType, bigEndianMod);\n\n\t\t\tconvertRet = keyConverterFunc(key);\n\t\t\tkeyBinLen = convertRet[\"binLen\"];\n\t\t\tkeyToUse = convertRet[\"value\"];\n\n\t\t\tblockByteSize = variantBlockSize >>> 3;\n\n\t\t\t/* These are used multiple times, calculate and store them */\n\t\t\tlastArrayIndex = (blockByteSize / 4) - 1;\n\n\t\t\t/* Figure out what to do with the key based on its size relative to\n\t\t\t * the hash's block size */\n\t\t\tif (blockByteSize < (keyBinLen / 8))\n\t\t\t{\n\n\t\t\t\tkeyToUse = finalizeFunc(keyToUse, keyBinLen, 0,getNewState(shaVariant), outputBinLen);\n\t\t\t\t/* For all variants, the block size is bigger than the output\n\t\t\t\t * size so there will never be a useful byte at the end of the\n\t\t\t\t * string */\n\t\t\t\twhile (keyToUse.length <= lastArrayIndex)\n\t\t\t\t{\n\t\t\t\t\tkeyToUse.push(0);\n\t\t\t\t}\n\t\t\t\tkeyToUse[lastArrayIndex] &= 0xFFFFFF00;\n\t\t\t}\n\t\t\telse if (blockByteSize > (keyBinLen / 8))\n\t\t\t{\n\t\t\t\t/* If the blockByteSize is greater than the key length, there\n\t\t\t\t * will always be at LEAST one \"useless\" byte at the end of the\n\t\t\t\t * string */\n\t\t\t\twhile (keyToUse.length <= lastArrayIndex)\n\t\t\t\t{\n\t\t\t\t\tkeyToUse.push(0);\n\t\t\t\t}\n\t\t\t\tkeyToUse[lastArrayIndex] &= 0xFFFFFF00;\n\t\t\t}\n\n\t\t\t/* Create ipad and opad */\n\t\t\tfor (i = 0; i <= lastArrayIndex; i += 1)\n\t\t\t{\n\t\t\t\tkeyWithIPad[i] = keyToUse[i] ^ 0x36363636;\n\t\t\t\tkeyWithOPad[i] = keyToUse[i] ^ 0x5C5C5C5C;\n\t\t\t}\n\n\t\t\tintermediateState = roundFunc(keyWithIPad, intermediateState);\n\t\t\tprocessedLen = variantBlockSize;\n\n\t\t\thmacKeySet = true;\n\t\t};\n\n\t\t/**\n\t\t * Takes strString and hashes as many blocks as possible.  Stores the\n\t\t * rest for either a future update or getHash call.\n\t\t *\n\t\t * @expose\n\t\t * @param {string|ArrayBuffer} srcString The string to be hashed\n\t\t */\n\t\tthis.update = function(srcString)\n\t\t{\n\t\t\tvar convertRet, chunkBinLen, chunkIntLen, chunk, i, updateProcessedLen = 0,\n\t\t\t\tvariantBlockIntInc = variantBlockSize >>> 5;\n\n\t\t\tconvertRet = converterFunc(srcString, remainder, remainderLen);\n\t\t\tchunkBinLen = convertRet[\"binLen\"];\n\t\t\tchunk = convertRet[\"value\"];\n\n\t\t\tchunkIntLen = chunkBinLen >>> 5;\n\t\t\tfor (i = 0; i < chunkIntLen; i += variantBlockIntInc)\n\t\t\t{\n\t\t\t\tif (updateProcessedLen + variantBlockSize <= chunkBinLen)\n\t\t\t\t{\n\t\t\t\t\tintermediateState = roundFunc(\n\t\t\t\t\t\tchunk.slice(i, i + variantBlockIntInc),\n\t\t\t\t\t\tintermediateState\n\t\t\t\t\t);\n\t\t\t\t\tupdateProcessedLen += variantBlockSize;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessedLen += updateProcessedLen;\n\t\t\tremainder = chunk.slice(updateProcessedLen >>> 5);\n\t\t\tremainderLen = chunkBinLen % variantBlockSize;\n\t\t\tupdatedCalled = true;\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the desired SHA hash of the string specified at instantiation\n\t\t * using the specified parameters\n\t\t *\n\t\t * @expose\n\t\t * @param {string} format The desired output formatting (B64, HEX,\n\t\t *   BYTES, or ARRAYBUFFER)\n\t\t * @param {{outputUpper : (boolean|undefined), b64Pad : (string|undefined),\n\t\t *   shakeLen : (number|undefined)}=} options Hash list of output formatting options\n\t\t * @return {string|ArrayBuffer} The string representation of the hash\n\t\t *   in the format specified.\n\t\t */\n\t\tthis.getHash = function(format, options)\n\t\t{\n\t\t\tvar formatFunc, i, outputOptions, finalizedState;\n\n\t\t\tif (true === hmacKeySet)\n\t\t\t{\n\t\t\t\tthrow new Error(\"Cannot call getHash after setting HMAC key\");\n\t\t\t}\n\n\t\t\toutputOptions = getOutputOpts(options);\n\n\t\t\tif ((isSHAKE === true) && ((8 & SUPPORTED_ALGS) !== 0))\n\t\t\t{\n\t\t\t\tif (outputOptions[\"shakeLen\"] === -1)\n\t\t\t\t{\n\t\t\t\t\tthrow new Error(\"shakeLen must be specified in options\");\n\t\t\t\t}\n\t\t\t\toutputBinLen = outputOptions[\"shakeLen\"];\n\t\t\t}\n\n\t\t\t/* Validate the output format selection */\n\t\t\tswitch (format)\n\t\t\t{\n\t\t\tcase \"HEX\":\n\t\t\t\tformatFunc = function(binarray) {return packed2hex(binarray, outputBinLen, bigEndianMod, outputOptions);};\n\t\t\t\tbreak;\n\t\t\tcase \"B64\":\n\t\t\t\tformatFunc = function(binarray) {return packed2b64(binarray, outputBinLen, bigEndianMod, outputOptions);};\n\t\t\t\tbreak;\n\t\t\tcase \"BYTES\":\n\t\t\t\tformatFunc = function(binarray) {return packed2bytes(binarray, outputBinLen, bigEndianMod);};\n\t\t\t\tbreak;\n\t\t\tcase \"ARRAYBUFFER\":\n\t\t\t\ttry {\n\t\t\t\t\ti = new ArrayBuffer(0);\n\t\t\t\t} catch (ignore) {\n\t\t\t\t\tthrow new Error(\"ARRAYBUFFER not supported by this environment\");\n\t\t\t\t}\n\t\t\t\tformatFunc = function(binarray) {return packed2arraybuffer(binarray, outputBinLen, bigEndianMod);};\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"format must be HEX, B64, BYTES, or ARRAYBUFFER\");\n\t\t\t}\n\n\t\t\tfinalizedState = finalizeFunc(remainder.slice(), remainderLen, processedLen, stateCloneFunc(intermediateState), outputBinLen);\n\t\t\tfor (i = 1; i < numRounds; i += 1)\n\t\t\t{\n\t\t\t\t/* This weird fix-up is only for the case of SHAKE algorithms\n\t\t\t\t * and outputBinLen is not a multiple of 32.  In this case, the\n\t\t\t\t * very last block of finalizedState has data that needs to be\n\t\t\t\t * ignored because all the finalizeFunc calls need to have\n\t\t\t\t * unneeded bits set to 0.\n\t\t\t\t */\n\t\t\t\tif (((8 & SUPPORTED_ALGS) !== 0) && (isSHAKE === true) && (outputBinLen % 32 !== 0))\n\t\t\t\t{\n\t\t\t\t\tfinalizedState[finalizedState.length - 1] &= 0x00FFFFFF >>> 24 - (outputBinLen % 32);\n\t\t\t\t}\n\t\t\t\tfinalizedState = finalizeFunc(finalizedState, outputBinLen, 0, getNewState(shaVariant), outputBinLen);\n\t\t\t}\n\n\t\t\treturn formatFunc(finalizedState);\n\t\t};\n\n\t\t/**\n\t\t * Returns the the HMAC in the specified format using the key given by\n\t\t * a previous setHMACKey call.\n\t\t *\n\t\t * @expose\n\t\t * @param {string} format The desired output formatting\n\t\t *   (B64, HEX, BYTES, or ARRAYBUFFER)\n\t\t * @param {{outputUpper : (boolean|undefined), b64Pad : (string|undefined),\n\t\t *   shakeLen : (number|undefined)}=} options associative array of output\n\t\t *   formatting options\n\t\t * @return {string|ArrayBuffer} The string representation of the hash in the\n\t\t *   format specified.\n\t\t */\n\t\tthis.getHMAC = function(format, options)\n\t\t{\n\t\t\tvar formatFunc,\tfirstHash, outputOptions, finalizedState;\n\n\t\t\tif (false === hmacKeySet)\n\t\t\t{\n\t\t\t\tthrow new Error(\"Cannot call getHMAC without first setting HMAC key\");\n\t\t\t}\n\n\t\t\toutputOptions = getOutputOpts(options);\n\n\t\t\t/* Validate the output format selection */\n\t\t\tswitch (format)\n\t\t\t{\n\t\t\tcase \"HEX\":\n\t\t\t\tformatFunc = function(binarray) {return packed2hex(binarray, outputBinLen, bigEndianMod, outputOptions);};\n\t\t\t\tbreak;\n\t\t\tcase \"B64\":\n\t\t\t\tformatFunc = function(binarray) {return packed2b64(binarray, outputBinLen, bigEndianMod, outputOptions);};\n\t\t\t\tbreak;\n\t\t\tcase \"BYTES\":\n\t\t\t\tformatFunc = function(binarray) {return packed2bytes(binarray, outputBinLen, bigEndianMod);};\n\t\t\t\tbreak;\n\t\t\tcase \"ARRAYBUFFER\":\n\t\t\t\ttry {\n\t\t\t\t\tformatFunc = new ArrayBuffer(0);\n\t\t\t\t} catch(ignore) {\n\t\t\t\t\tthrow new Error(\"ARRAYBUFFER not supported by this environment\");\n\t\t\t\t}\n\t\t\t\tformatFunc = function(binarray) {return packed2arraybuffer(binarray, outputBinLen, bigEndianMod);};\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"outputFormat must be HEX, B64, BYTES, or ARRAYBUFFER\");\n\t\t\t}\n\n\t\t\tfirstHash = finalizeFunc(remainder.slice(), remainderLen, processedLen, stateCloneFunc(intermediateState), outputBinLen);\n\t\t\tfinalizedState = roundFunc(keyWithOPad, getNewState(shaVariant));\n\t\t\tfinalizedState = finalizeFunc(firstHash, outputBinLen, variantBlockSize, finalizedState, outputBinLen);\n\n\t\t\treturn formatFunc(finalizedState);\n\t\t};\n\t};\n\n\tif ((\"function\" === typeof define) && (define[\"amd\"])) /* AMD Support */\n\t{\n\t\tdefine(function()\n\t\t{\n\t\t\treturn jsSHA;\n\t\t});\n\t} else if (\"undefined\" !== typeof exports) /* Node Support */\n\t{\n\t\tif ((\"undefined\" !== typeof module) && module[\"exports\"])\n\t\t{\n\t\t  module[\"exports\"] = jsSHA;\n\t\t  exports = jsSHA;\n\t\t}\n\t\telse {\n\t\t\texports = jsSHA;\n\t\t}\n\t} else { /* Browsers and Web Workers*/\n\t\tglobal[\"jsSHA\"] = jsSHA;\n\t}\n}(this));\n"]}